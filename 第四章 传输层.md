

### <a name="toc-transport"></a>传输层 (Transport Layer) - 知识点索引

*   [**4.1 传输层概述**](#41-传输层概述)
    *   [4.1.1 传输层的两个重要协议](#411-传输层的两个重要协议)
        *   `TCP (传输控制协议)`
        *   `UDP (用户数据报协议)`
        *   `面向连接 / 无连接`
        *   `可靠 / 不可靠`
    *   [4.1.2 传输层复用、分用和端口](#412-传输层复用分用和端口)
        *   `端口号 (Port Number)`
        *   `复用 (Multiplexing)`
        *   `分用 (Demultiplexing)`
        *   `套接字 (Socket)`
        *   `五元组`
*   [**4.2 用户数据报协议 (UDP)**](#42-用户数据报协议-udp)
    *   [4.2.1 UDP 概述与报文格式](#421-udp-概述与报文格式)
        *   `尽力而为 (Best-effort)`
        *   `面向报文`
        *   `用户数据报 (User Datagram)`
        *   `UDP首部 (Header)`
        *   `校验和 (Checksum)`
        *   `伪首部`
        *   `单播 (Unicast)`
        *   `广播 (Broadcast)`
        *   `多播 (Multicast)`
*   [**4.3 可靠传输原理**](#43-可靠传输原理)
    *   [4.3.1 停止-等待协议](#431-停止-等待协议)
        *   `停止-等待 (Stop-and-Wait)`
        *   `确认 (ACK)`
        *   `超时重传 (Timeout Retransmission)`
        *   `分组编号`
    *   [4.3.2 连续ARQ协议](#432-连续arq协议)
        *   `连续ARQ (Continuous ARQ)`
        *   `滑动窗口 (Sliding Window)`
        *   `回退N帧 (Go-Back-N, GBN)`
        *   `选择重传 (Selective Repeat, SR)`
*   [**4.4-4.8 传输控制协议 (TCP)**](#44-48-传输控制协议-tcp)
    *   [4.4 TCP 概述与报文格式](#44-tcp-概述与报文格式)
        *   `面向字节流 (Byte-Stream-Oriented)`
        *   `全双工通信`
        *   `报文段 (Segment)`
        *   `序号 (Sequence Number)`
        *   `确认号 (Acknowledgement Number)`
        *   `标志位 (Flags - SYN, ACK, FIN, RST)`
        *   `窗口大小 (Window Size)`
    *   [4.5 TCP 的连接管理](#45-tcp-的连接管理)
        *   `三次握手 (Three-way Handshake)`
        *   `四次挥手 (Four-way Handshake)`
        *   `半关闭 (Half-close)`
        *   `TIME-WAIT 状态`
        *   `MSL (报文最大生存时间)`
    *   [4.6 TCP 的可靠传输](#46-tcp-的可靠传输)
        *   `累计确认`
        *   `超时重传 (RTO)`
        *   `往返时间 (RTT)`
        *   `快速重传 (Fast Retransmit)`
        *   `重复确认 (Duplicate ACK)`
        *   `SACK (选择性确认)`
    *   [4.7 TCP 的流量控制](#47-tcp-的流量控制)
        *   `流量控制 (Flow Control)`
        *   `接收窗口 (rwnd)`
        *   `零窗口 (Zero Window)`
        *   `持续定时器 (Persistence Timer)`
        *   `窗口探测 (Window Probe)`
    *   [4.8 TCP 的拥塞控制](#48-tcp-的拥塞控制)
        *   `拥塞 (Congestion)`
        *   `拥塞窗口 (cwnd)`
        *   `慢启动 (Slow Start)`
        *   `拥塞避免 (Congestion Avoidance)`
        *   `慢启动阈值 (ssthresh)`
        *   `快速恢复 (Fast Recovery)`
        *   `AIMD (加性增, 乘性减)`
        *   `ECN (显式拥塞通知)`
    *   [拓展：TCP 的定时器](#拓展-tcp-的定时器)
        *   `重传定时器`
        *   `持续定时器`
        *   `保活定时器 (Keepalive Timer)`
        *   `时间等待定时器 (TIME-WAIT Timer)`

---


---

### **4.1 传输层概述**
[返回目录](#toc-transport)
#### **4.1.1 传输层的两个重要协议**

[返回目录](#toc-transport)

传输层为应用层提供了两种截然不同、但都至关重要的服务。这两种服务分别由两个核心协议来提供：

1.  **TCP (Transmission Control Protocol - 传输控制协议)**

    *   **服务类型**: **面向连接的、可靠的** 数据传输服务。
    *   **核心特征**:
        *   **面向连接 (Connection-oriented)**: 在传输数据之前，通信双方的TCP协议栈必须先建立一个虚拟的连接（“三次握手”）。所有数据都在这个连接上传输，传输结束后再释放连接（“四次挥手”）。
        *   **可靠性 (Reliable)**: TCP提供了一整套复杂的机制来确保数据传输的可靠性。它保证：
            *   **无差错**: 通过校验和机制，丢弃损坏的数据包。
            *   **不丢失**: 通过确认和超时重传机制，确保丢失的数据包能被重发。
            *   **不重复**: 通过序号机制，丢弃重复的数据包。
            *   **按顺序**: 通过序号机制，对失序到达的数据包进行重新排序。
        *   **全双工通信**: 连接建立后，双方可以同时进行数据的发送和接收。
        *   **流量控制 (Flow Control)**: 控制发送方的发送速率，防止过快的数据淹没接收方。
        *   **拥塞控制 (Congestion Control)**: 感知网络拥塞状况，动态调整发送速率，避免造成网络崩溃。
    *   **应用场景**: 适用于对数据**完整性和顺序**有严格要求的应用，如**网页浏览(HTTP)、文件传输(FTP)、电子邮件(SMTP)**。

3.  **UDP (User Datagram Protocol - 用户数据报协议)**
    *   **服务类型**: **无连接的、不可靠的** 数据传输服务。
    *   **核心特征**:
        *   **无连接 (Connectionless)**: 发送数据前不需要建立连接，想发就发。每个数据报（Datagram）都是一个独立的、与其他数据报无关的单元。
        *   **不可靠 (Unreliable)**: UDP奉行**“尽力而为 (Best-effort)”** 的原则。它不保证数据能成功到达，不保证按序到达，也不保证不重复。如果数据包在传输中丢失、损坏或失序，UDP协议本身**不采取任何措施**。
        *   **开销小，速度快**: 正因为它省去了所有保证可靠性的复杂机制，所以它的协议头部非常小（仅8字节），处理速度极快。
        *   **面向报文**: UDP保留了应用层消息的边界。应用层交下来一个多大的数据块，UDP就给它加上头部，原封不动地发出去。
    *   **应用场景**: 适用于对**实时性**要求高、能容忍少量丢包的应用，如**域名解析(DNS)、动态主机配置(DHCP)、实时视频流、在线游戏、网络电话(VoIP)**。

#### **4.1.2 传输层复用、分用和端口**

[返回目录](#toc-transport)

这是传输层最基本、也是最重要的功能。

*   **问题**: 网络层（IP协议）只负责将数据包从**源主机**送到**目的主机**。但一台主机上可能同时运行着多个需要联网的应用程序（浏览器、微信、游戏等）。当一个数据包到达目的主机时，操作系统内核的网络协议栈如何知道应该把这个数据包交给哪个应用程序呢？

*   **解决方案**: **端口号 (Port Number)**。

    *   **端口号**: 一个16位的数字（范围0-65535），用于在**一台主机**内部标识一个特定的**应用程序进程**。
    *   **复用 (Multiplexing)**: 在**发送端**，传输层（TCP或UDP）从多个不同的应用进程（通过不同的端口号标识）收集数据，为它们分别封装上正确的端口号信息，然后将这些数据段（Segments）或数据报（Datagrams）一同传递给下层的网络层。这就好像一个邮局的收件员，从不同的人（应用进程）手里收集信件，装进同一个邮袋里发出去。
    *   **分用 (Demultiplexing)**: 在**接收端**，传输层根据收到的数据段或数据报头部的**目的端口号**，来决定应该将数据交付给哪个上层应用程序。这就好像邮局的派件员，根据信封上的“房间号”（端口号），把信准确地投递到对应的住户（应用进程）手里。

*   **套接字 (Socket)**:
    *   一个完整的网络通信连接，是由一个**五元组**来唯一标识的：
        `{传输层协议, 源IP地址, 源端口号, 目的IP地址, 目的端口号}`
    *   这个五元组定义了一个唯一的套接字对，确保了即使同一个主机上的同一个应用程序（比如浏览器打开了多个标签页），它们各自的通信也不会混淆。

---


### **4.2 用户数据报协议 (UDP)**

[返回目录](#toc-transport)

#### **4.2.1 用户数据报协议概述**

[返回目录](#toc-transport)

**UDP (User Datagram Protocol)** 是TCP/IP协议栈中与TCP并列的另一个核心传输层协议。它提供了一种极其简单的、**无连接的、不可靠的**数据报服务。

**UDP的核心设计哲学：简单、快速、尽力而为。**

*   **“无连接”的含义**:
    *   UDP在发送数据之前，**不需要**像TCP那样先通过“三次握手”建立连接。
    *   发送方可以随时将数据打包成UDP数据报并发送出去，就像寄平信一样，写好地址就扔进邮筒，不用先打电话确认对方是否在家。
    *   每个UDP数据报都是一个独立的单元，在网络中被独立地路由，它们之间没有上下文关系。

*   **“不可靠”的含义**:
    *   UDP不提供任何可靠性保证。它只是简单地将应用层的数据加上UDP头部，然后就“尽最大努力”地交给下层的IP协议去传输。
    *   它**不保证**：
        *   数据报一定能到达目的地（可能会在网络中丢失）。
        *   数据报的到达顺序与发送顺序一致（可能会失序）。
        *   数据报在传输过程中没有损坏（虽然有校验和，但出错的数据报通常只是被静默丢弃）。
    *   **可靠性必须由上层应用自己来保证**。如果应用需要可靠传输，就必须自己在程序中实现确认、重传等逻辑（QUIC协议就是这么做的）。

*   **UDP的优点**:
    1.  **开销小，速度快**: 因为没有复杂的连接管理、确认、重传、流量控制等机制，UDP的协议头部非常小，处理速度非常快。
    2.  **支持一对一、一对多、多对一、多对多的交互通信**: 由于其无连接的特性，非常灵活。
    3.  **保留应用消息边界**: UDP是面向报文的。应用层给UDP一个100字节的消息，UDP就发送一个100字节的数据报；应用层给一个20字节的消息，UDP就发一个20字节的数据报。它不会像TCP那样将数据合并或拆分。

#### **4.2.2 UDP用户数据报格式**

[返回目录](#toc-transport)

UDP的数据单元称为**用户数据报 (User Datagram)**。它的结构分为两部分：**UDP首部 (Header)** 和 **UDP数据区 (Payload)**。

UDP的首部格式极其简单，是固定的 **8个字节 (64位)**。

```
  0      7 8     15 16    23 24    31
 +--------+--------+--------+--------+
 |     Source      |   Destination   |
 |      Port       |      Port       |
 +--------+--------+--------+--------+
 |     Length      |    Checksum     |
 +--------+--------+--------+--------+
 |
 |          data payload ...
 |
 +---------------- ...

```

**UDP首部字段详解**:

*   **源端口 (Source Port, 16位)**
    *   标识发送方应用程序进程的端口号。
    *   这个字段是**可选的**。对于一个只发送数据而不需要接收响应的单向通信应用，源端口可以全置为0。但在大多数情况下（如DNS查询），客户端会填上自己的端口，以便服务器能将响应发回。

*   **目的端口 (Destination Port, 16位)**
    *   标识接收方应用程序进程的端口号。
    *   这个字段是**必须的**。

*   **长度 (Length, 16位)**
    *   该字段指定了整个UDP用户数据报的**总长度**，单位是字节。
    *   总长度 = UDP首部长度 (8字节) + UDP数据区长度。
    *   16位意味着UDP数据报的最大长度是 `2^16 - 1 = 65535` 字节。但由于下层IP协议的限制，实际能传输的数据通常要小得多（约65507字节）。

*   **校验和 (Checksum, 16位)**
    *   用于检测UDP用户数据报在传输过程中是否出现了**差错**（比如比特翻转）。
    *   这个字段是**可选的**。在IPv4中，如果发送端没有计算校验和，则该字段全置为0。但在IPv6中，校验和是**强制**的。
    *   **计算范围**: 校验和的计算不仅包括UDP首部和数据区，还包括一个从IP数据包头部提取出来的“伪首部”（包含源/目的IP地址、协议号等信息）。将IP地址包含进来，可以防止数据报被错误地路由到其他主机后还能校验通过。
    *   **差错处理**: 如果接收端计算出的校验和与该字段的值不符，就认为数据报在传输中损坏了，会**静默地丢弃**这个数据报，**不会**通知发送方。

---


### **通信模式：单播、广播、多播**

[返回目录](#toc-transport)

首先，我们来定义这三种通信模式。它们描述的是一个数据包从“一个源”出发后，最终期望被“多少个目标”接收。

**1. 单播 (Unicast)**

*   **定义**: **一对一 (One-to-One)** 的通信。数据包从一个唯一的源地址，被发送到一个唯一的目的地址。
*   **特征**: 网络中的路由器会根据目的地址，为这个数据包寻找一条精确的路径，最终只将其投递给唯一的目标主机。
*   **比喻**: **打电话**。你拨打一个特定的号码，只有那个号码对应的电话会响。
*   **应用**: 这是互联网上**最常见**的通信模式，我们日常的网页浏览(HTTP)、文件下载(FTP)、收发邮件(SMTP/POP3/IMAP)等，全部都是单播。

**2. 广播 (Broadcast)**

*   **定义**: **一对所有 (One-to-All)** 的通信。数据包从一个源地址，被发送到一个子网内的**所有**主机。
*   **特征**: 广播通常被限制在一个**广播域**（通常是一个局域网）内，**路由器默认不会转发广播包**，以防止广播风暴淹没整个互联网。广播使用一个特殊的目的地址（如 `255.255.255.255` 或子网广播地址 `192.168.1.255`）。
*   **比喻**: **大喇叭喊话**。你在一个办公大厅里用大喇叭喊话，大厅里的所有人都能听到。
*   **应用**: 主要用于局域网内的**服务发现**，比如**DHCP**客户端寻找DHCP服务器，或者**ARP**协议寻找IP地址对应的MAC地址。

**3. 多播 (Multicast) / 组播**

*   **定义**: **一对一组 (One-to-Many)** 的通信。数据包从一个源地址，被发送到一个特定的“多播组”地址。只有**主动加入了这个组**的主机，才会收到这份数据包。
*   **特征**:
    *   **高效性**: 发送者只需发送一份数据，网络中的路由器会负责在必要的分叉点对数据包进行**复制和分发**，只将数据投递给那些下游有组成员的网络链路上。这极大地节省了服务器的带宽。
    *   **选择性**: 不像广播那样强制所有人都接收，多播允许主机自由选择加入或离开一个组。
*   **比喻**: **订阅杂志/邮件列表**。只有订阅了某份杂志的人，才会收到这份杂志。
*   **应用**: **在线视频直播**、**网络电视 (IPTV)**、**多人视频会议**、**在线多人游戏**、**金融市场数据分发**等。

---

### **TCP 和 UDP 对这三种模式的支持情况**

[返回目录](#toc-transport)

现在，我们来看TCP和UDP这两个传输层协议如何与这三种通信模式相结合。

**1. UDP (用户数据报协议)**

UDP是无连接的、轻量级的协议，这使得它非常灵活。

*   **支持单播 (Unicast)**: **支持**。这是UDP的常规用法。例如，DNS查询就是一个典型的UDP单播应用。

*   **支持广播 (Broadcast)**: **支持**。DHCP和ARP（虽然ARP工作在网络层和数据链路层之间，但其广播发现的理念与此类似）就是利用广播来寻找服务器。

*   **支持多播 (Multicast)**: **大力支持**。可以说，UDP是实现多播应用的**首选和标准**传输层协议。几乎所有我们上面提到的多播应用（视频流、在线游戏等），其数据流都是通过UDP来承载的。因为这些应用通常对实时性要求很高，能容忍少量丢包，这与UDP的特性完美契合。

**总结：UDP 支持 单播、广播、多播。**

**2. TCP (传输控制协议)**

TCP是面向连接的、可靠的协议，这个核心特性决定了它对通信模式的支持。

*   **支持单播 (Unicast)**: **大力支持**。TCP的设计初衷就是为了提供**点对点**的、可靠的单播通信。所有基于TCP的应用，如HTTP、FTP、SMTP等，都是单播应用。

*   **支持广播 (Broadcast)**: **不支持**。
    *   **原因**: TCP的**核心是“连接”**。建立一个TCP连接需要**三次握手**，这个过程必须在**两个明确的端点**之间进行。而广播的目的地址是“网络中的所有人”，它不是一个明确的端点，你无法与“所有人”同时进行三次握手并建立一个可靠的连接。

*   **支持多播 (Multicast)**: **不支持**。
    *   **原因**: 与广播类似，多播的目的地址是一个“组”，而不是一个单一的端点，因此无法进行TCP的三次握手。此外，TCP的**可靠性机制**（确认、重传、流量控制）在多播场景下会变得极其复杂且低效。
        *   想象一下，如果一个多播组里有1000个接收者，其中999个都收到了包，只有1个没收到。发送方是否要为了这1个人，向所有人重传？还是只给那1个人重传？如果同时有几十个人丢了不同的包，发送方就会被大量的确认和重传请求（ACK风暴）所淹没。
        *   因此，TCP的可靠模型与多播的“一对多”模型在根本上是**不兼容**的。

**总结：TCP 只支持 单播。**

---



### **4.3 可靠传输原理**

[返回目录](#toc-transport)

我们已经知道，UDP提供的是不可靠的传输，而TCP提供的是可靠的传输。那么，“可靠性”究竟是如何实现的呢？

网络层的IP协议是不可靠的，它可能会导致数据包**出错（比特翻转）、丢失、重复或失序**。可靠传输协议的目标，就是在这样一条不可靠的信道上，构建出一个对上层应用来说**完全可靠**的逻辑信道。

为了实现这个目标，我们需要逐步解决一系列问题，这个解决过程也正好对应了可靠传输协议的演进。我们从最简单的协议开始。

#### **4.3.1 停止-等待协议 (Stop-and-Wait Protocol)**<a name="431-停止-等待协议"></a>

[返回目录](#toc-transport)

这是最简单、最基础的可靠传输协议。它的核心思想是：**发送方每发送一个分组，就必须停下来，等待接收方的确认 (Acknowledgement, ACK)，收到确认后才能发送下一个分组。**

**1. 基本场景：无差错信道**

*   **流程**:
    1.  发送方发送分组0。
    2.  接收方收到分组0，向上层交付数据，然后回复一个ACK0。
    3.  发送方收到ACK0，知道分组0已成功送达，于是发送分组1。
    4.  ...如此循环。

**2. 引入差错：确认和超时重传**

*   **问题**: 如果分组在传输中**丢失**了，或者**损坏**了（接收方通过校验和发现并丢弃），发送方将永远等不到ACK，就会陷入**死锁**。
*   **解决方案**:
    1.  **确认 (ACK)**: 接收方收到正确的分组后，必须回复一个确认分组。
    2.  **超时重传 (Timeout Retransmission)**: 发送方在发送完一个分组后，会启动一个**定时器**。
        *   如果在定时器超时之前，收到了对应的ACK，就关闭定时器，发送下一个分组。
        *   如果在定时器超时之后，**仍然没有**收到ACK，发送方就**假定**之前发送的分组已经丢失，并**重新发送**同样的分组。

**3. 引入重复：分组编号**

*   **问题**: 超时重传又引入了新问题。
    *   **ACK丢失**: 如果分组成功到达，但接收方返回的ACK在路上丢失了。发送方定时器超时，会**重传**分组。接收方会收到一个**重复的分组**。
    *   **ACK迟到**: 如果ACK只是传输延迟，没有丢失。发送方超时重传了分组，然后又收到了那个迟到的ACK。
*   **解决方案**: **分组编号**。
    *   发送方为每个分组都赋予一个**唯一的序号 (Sequence Number)**。最简单的停止-等待协议只需要两个序号：0和1，交替使用。
    *   **发送方**: 维护一个发送序号，发送分组0，然后等待ACK0。收到ACK0后，下一个发送序号变为1。
    *   **接收方**: 维护一个期望接收的序号。
        *   如果收到的分组序号**等于**期望的序号，就接收它，向上层交付，然后将期望序号+1（或在0和1之间切换），并回复一个对应序号的ACK。
        *   如果收到的分组序号**不等于**期望的序号，说明这是一个**重复的分组**，就直接**丢弃**它，但依然要回复一个**上一个正确序号的ACK**（告诉发送方“我还在等那个旧的”）。

**停止-等待协议的总结**

*   **优点**: 简单易懂，是所有复杂可靠传输协议的基础。
*   **缺点**: **信道利用率极低**。在发送完一个分组后，整个信道在“等待ACK”的漫长时间里都是空闲的。这就像你寄一封信，必须等对方回信说收到了，你才能寄下一封，效率非常低下。

---

#### **4.3.2 连续ARQ协议 (Continuous ARQ Protocol)**

[返回目录](#toc-transport)

为了解决停止-等待协议的效率问题，**连续ARQ协议**应运而生。ARQ (Automatic Repeat reQuest) 即自动重传请求。

**核心思想**: 发送方可以**连续发送多个分组**，而无需每发送一个就停下来等待确认。这就像你可以一次性把一摞信都投进邮筒，而不用等第一封的回信。

为了实现这一点，连续ARQ协议引入了**滑动窗口 (Sliding Window)** 的概念。

**1. 滑动窗口**

*   **发送窗口**:
    *   在发送方，维护着一个允许它连续发送的分组序号范围，这个范围就是**发送窗口**。
    *   位于发送窗口内的分组，都可以被连续发送出去，而无需等待确认。
    *   发送窗口会随着收到接收方的确认而向前滑动。

*   **接收窗口**:
    *   在接收方，也维护着一个允许它接收的分组序号范围，这就是**接收窗口**。
    *   只有序号落在接收窗口内的分组才会被接收。

**2. 两种经典的连续ARQ协议**

连续ARQ协议主要有两种具体的实现方式，它们的区别在于如何处理出错/丢失的分组。

**A. 回退N帧协议 (Go-Back-N, GBN)**

*   **工作机制**:
    *   **发送窗口**: 大小可以 > 1。
    *   **接收窗口**: 大小**恒等于1**。
    *   **接收方**: 只接收**按序到达**的分组。如果收到了一个失序的分组（比如期望收到5号，却收到了7号），它会**直接丢弃**7号以及后续所有到达的分组，并反复发送对最后一个正确分组的确认（ACK4）。
    *   **发送方**:
        *   维护一个定时器，通常只为**最早发送但尚未被确认**的分组计时。
        *   如果定时器超时，发送方会**重新发送**那个超时的分组以及**它之后所有已发送过**的分组。这就是“回退N帧”这个名字的由来。
*   **优点**: 接收方逻辑简单，无需缓存失序的分组。
*   **缺点**: **效率较低**。即使后面只有一个分组出错，也要重传大量本已正确到达的分组，浪费了带宽。

**B. 选择重传协议 (Selective Repeat, SR)**

*   **工作机制**:
    *   **发送窗口**: 大小 > 1。
    *   **接收窗口**: 大小**也 > 1**。
    *   **接收方**:
        *   可以**缓存**那些失序到达、但序号落在接收窗口内的分组。
        *   对**每一个正确接收**的分组都**单独发送确认 (SACK - Selective ACK)**。
        *   当收到了一个期望的序号后（比如空缺的5号补上了），就可以将一段连续的分组向上层交付，并滑动接收窗口。
    *   **发送方**:
        *   为**每一个已发送但未确认**的分组都维护一个独立的定时器。
        *   如果哪个分组的定时器超时了，发送方**只重传那一个**分组。
*   **优点**: **效率极高**。实现了“哪里出错就补哪里”，最大限度地避免了不必要的重传。
*   **缺点**: 发送方和接收方的逻辑都**非常复杂**，需要维护更精细的状态和缓存。

**总结**
*   **TCP协议**的可靠传输机制，可以看作是**GBN和SR协议的混合体**。它在很多方面借鉴了这两种协议的思想，并进行了优化和改进，从而在复杂性和效率之间取得了很好的平衡。

---


### **4.4 传输控制协议 (TCP)**

[返回目录](#toc-transport)

#### **4.4.1 传输控制协议概述**

[返回目录](#toc-transport)

**TCP (Transmission Control Protocol)** 是TCP/IP协议栈中负责提供**可靠的、面向连接的**字节流服务的传输层协议。它是互联网上绝大多数应用（Web、Email、FTP等）的基石。

**TCP的核心特点回顾与深化**:

1.  **面向连接 (Connection-Oriented)**
    *   TCP通信的双方必须在传输数据之前，通过一个称为**“三次握手”**的过程来建立一个逻辑连接。
    *   这个连接为数据传输提供了一个可靠的通道。
    *   数据传输结束后，需要通过**“四次挥手”**来释放连接。

2.  **可靠传输 (Reliable Transport)**
    *   TCP利用我们在上一节学到的原理，并加以优化，来实现可靠性。它通过**序号、确认、超时重传、校验和**等机制，确保数据**不丢失、不重复、无差错、按顺序**地送达。

3.  **全双工通信 (Full-Duplex Communication)**
    *   在一个TCP连接上，通信双方的数据通路是双向的。两端可以**同时**进行数据的发送和接收。

4.  **面向字节流 (Byte-Stream-Oriented)**
    *   **这是TCP一个非常重要的概念**，与UDP的“面向报文”形成鲜明对比。
    *   **含义**: TCP不关心应用层传递下来的数据块的边界。在TCP看来，它要传输的数据，只是一个**无结构的、连续的字节序列**，就像一个流动的字节河。
    *   **行为**:
        *   TCP可能会将应用层发来的一个大数据库，**拆分**成多个小的TCP报文段来发送。
        *   也可能会将应用层连续发来的几个小数据块，**合并 (Nagle算法)** 成一个大的TCP报文段来发送，以提高网络效率。
    *   **对应用层的影响**: 接收方的应用程序从TCP接收数据时，也需要像从“河流”中读取数据一样，自己处理数据的边界问题。例如，发送方发送了两个HTTP请求，接收方可能一次性从TCP缓冲区里读出来一个半请求，需要应用层自己来解析和分割。

#### **4.4.2 TCP报文段格式**

[返回目录](#toc-transport)

TCP的数据单元称为**报文段 (Segment)**。它的首部（头部）比UDP复杂得多，包含了实现其可靠性、流量控制、拥塞控制等各种功能的字段。

TCP首部的**固定部分是20字节**，后面还可以跟最多40字节的选项字段。

```
  0      7 8     15 16    23 24    31
 +--------+--------+--------+--------+
 |     Source      |   Destination   |
 |      Port       |      Port       |
 +--------+--------+--------+--------+
 |                                   |
 |        Sequence Number (32)       |
 |                                   |
 +--------+--------+--------+--------+
 |                                   |
 |     Acknowledgement Number (32)   |
 |                                   |
 +--------+--------+--------+--------+
 | DO |  Reservd |   Flags (6)   |  Window Size (16)   |
 +--------+--------+--------+--------+
 |    Checksum (16)    | Urgent Pointer (16) |
 +--------+--------+--------+--------+
 |      Options (if any) ...       |
 +--------+--------+--------+--------+
 |                                   |
 |              Data ...             |
 |                                   |
 +-----------------------------------+

```

**TCP首部关键字段详解**:

*   **源端口 (Source Port, 16位)** 和 **目的端口 (Destination Port, 16位)**
    *   作用同UDP，用于标识发送和接收方的应用进程。

*   **序号 (Sequence Number, 32位)**
    *   **TCP最核心的字段之一**。
    *   由于TCP是面向字节流的，这个序号指的是本报文段所发送的**数据部分的第一个字节**在整个字节流中的**编号**。
    *   例如，如果一个报文段的序号是301，它携带了100字节的数据，那么这个报文段的数据就是字节流中的第301到400号字节。下一个报文段的序号就应该是401。
    *   **作用**: 实现数据的有序传输和确认机制。

*   **确认号 (Acknowledgement Number, 32位)**
    *   **TCP最核心的字段之二**。
    *   这个字段只有在 **ACK标志位** (见下) 为1时才有效。
    *   **含义**: 它告诉对方：“**我期望接收的下一个字节的序号是 `N`**”。这也就**隐含地确认**了序号在 `N-1` 之前的所有字节，我都已经**全部、正确地、按序地**收到了。这是一种**累计确认**机制。

*   **数据偏移 (Data Offset, 4位)**
    *   指的是TCP首部的长度，单位是 **4字节**。
    *   因为TCP首部有可选字段，所以长度是可变的。这个字段告诉接收方数据部分从哪里开始。
    *   4位能表示的最大值是15，所以TCP首部的最大长度是 `15 * 4 = 60` 字节。

*   **标志位 (Flags, 6位)**
    *   这是6个独立的比特位，每一位都有特殊的控制功能。
    *   **URG (Urgent)**: 紧急位。指示报文段中有紧急数据。
    *   **ACK (Acknowledgement)**: **确认位**。当ACK=1时，**确认号**字段才有效。
    *   **PSH (Push)**: 推送位。指示接收方应尽快将这个报文段的数据交付给应用层，而不要等待缓冲区填满。
    *   **RST (Reset)**: 复位位。用于异常地关闭一个连接。
    *   **SYN (Synchronization)**: **同步位**。在**连接建立**（三次握手）时使用，表示这是一个连接请求或连接接受报文。
    *   **FIN (Finish)**: **终止位**。在**连接释放**（四次挥手）时使用，表示发送方的数据已全部发送完毕。

*   **窗口大小 (Window Size, 16位)**
    *   用于**流量控制**。
    *   这个字段的值，是发送本报文段的一方（接收方）告诉对方（发送方）：“我现在的接收缓冲区还剩下 `N` 个字节的空间，你可以继续发送数据，但不要超过这个量。”
    *   它动态地向发送方宣告自己的接收能力。

*   **校验和 (Checksum, 16位)**
    *   用于检验首部和数据部分在传输过程中是否出错。计算方法与UDP类似，也包含一个IP伪首部。

*   **紧急指针 (Urgent Pointer, 16位)**
    *   只有当URG标志位为1时才有效，指出紧急数据在报文段中的结束位置。

*   **选项 (Options, 可变长)**
    *   用于携带一些额外的参数，如最大报文段长度 (MSS)、窗口扩大因子、选择性确认 (SACK) 信息等。

---



### **4.5 TCP的连接管理**

[返回目录](#toc-transport)

TCP是一个面向连接的协议，这意味着在数据传输之前，必须先创建一个“连接”；数据传输完毕后，必须释放这个“连接”。这个创建和释放的过程，就是由著名的“三次握手”和“四次挥手”来完成的。

#### **4.5.1 TCP的连接建立 (三次握手)**

[返回目录](#toc-transport)

**目标**: 通信双方需要通过三次交互，来**同步彼此的初始序号 (Initial Sequence Number, ISN)**，并确认双方都有**发送和接收**数据的能力。

**场景**: 客户端 (Client) 主动向服务器 (Server) 发起连接请求。

**三次握手流程**:

1.  **第一次握手 (SYN)**: **客户端 -> 服务器**
    *   **动作**: 客户端想要建立连接，它会创建一个TCP报文段，将 **SYN标志位置为1**，并随机选择一个**初始序号 `seq = x`**。
    *   **状态**: 客户端发送完毕后，进入 `SYN-SENT` (同步已发送) 状态。
    *   **含义**: “你好，服务器！我想和你建立连接，我的初始序号是x，你听得到吗？”

2.  **第二次握手 (SYN+ACK)**: **服务器 -> 客户端**
    *   **动作**: 服务器收到了客户端的SYN报文。如果同意连接，它会回复一个TCP报文段，这个报文段同时设置了 **SYN标志位=1** 和 **ACK标志位=1**。
    *   服务器也会为自己的数据流随机选择一个**初始序号 `seq = y`**。
    *   同时，它会设置**确认号 `ack = x + 1`**，表示“我已经收到了你序号为x的报文，我期望你下一个发送的字节序号是x+1”。
    *   **状态**: 服务器发送完毕后，进入 `SYN-RCVD` (同步已接收) 状态。
    *   **含义**: “你好，客户端！我听到了。我也想和你建立连接，我的初始序号是y。我已经收到了你的序号x，现在我期望收到x+1。”

3.  **第三次握手 (ACK)**: **客户端 -> 服务器**
    *   **动作**: 客户端收到了服务器的SYN+ACK报文。它会回复最后一个确认报文段，设置 **ACK标志位=1**。
    *   它的序号是 `seq = x + 1` (因为第一次握手的SYN报文虽然不带数据，但要消耗一个序号)。
    *   它的确认号是 `ack = y + 1`，表示“我已经收到了你序号为y的报文，我期望你下一个发送的字节序号是y+1”。
    *   **状态**: 客户端发送完毕后，进入 `ESTABLISHED` (已建立连接) 状态。当服务器收到这个ACK报文后，也进入 `ESTABLISHED` 状态。
    *   **含义**: “好的，服务器！我也收到了你的信息。现在我期望收到y+1。连接建立成功！”

**为什么必须是三次握手？**
*   **两次握手不够**: 无法防止“已失效的连接请求报文段”突然又传送到服务器，从而引发错误。如果只有两次握手，服务器收到一个旧的SYN后，会立即建立连接并等待客户端数据，而客户端并不会理睬，这会浪费服务器资源。
*   **核心目的**: 三次握手确保了**双方都确认了对方的接收和发送能力都正常**，并完成了彼此初始序号的同步。

#### **4.5.2 TCP的连接释放 (四次挥手)**

**目标**: 由于TCP是全双工的，连接释放需要双方**各自独立地**关闭自己这一方向的发送通道。

**场景**: 假设客户端主动发起关闭请求。

**四次挥手流程**:

1.  **第一次挥手 (FIN)**: **客户端 -> 服务器**
    *   **动作**: 客户端的数据已全部发送完毕，它会发送一个TCP报文段，将 **FIN标志位置为1**，并包含一个序号 `seq = u`。
    *   **状态**: 客户端进入 `FIN-WAIT-1` (终止等待1) 状态。
    *   **含义**: “服务器，我这边的数据已经发完了，我准备要关闭发送通道了。”

2.  **第二次挥手 (ACK)**: **服务器 -> 客户端**
    *   **动作**: 服务器收到了客户端的FIN报文。它会立即回复一个**确认报文段 (ACK=1)**，确认号为 `ack = u + 1`。
    *   **状态**: 服务器进入 `CLOSE-WAIT` (关闭等待) 状态。客户端收到这个ACK后，进入 `FIN-WAIT-2` 状态。
    *   **含义**: “好的，客户端，我已经收到你的关闭请求了。但是我这边可能还有数据没发完，请你等一下。”
    *   **半关闭 (Half-close)**: 此时，从客户端到服务器方向的连接已经关闭，但从服务器到客户端方向的连接仍然是打开的。服务器仍然可以向客户端发送数据。

3.  **第三次挥手 (FIN)**: **服务器 -> 客户端**
    *   **动作**: 当服务器也完成了所有数据的发送后，它会向客户端发送一个 **FIN报文段 (FIN=1)**，并包含自己的序号 `seq = v`。
    *   **状态**: 服务器发送完毕后，进入 `LAST-ACK` (最后确认) 状态。
    *   **含义**: “客户端，我这边的数据也全部发完了，现在我也准备关闭发送通道了。”

4.  **第四次挥手 (ACK)**: **客户端 -> 服务器**
    *   **动作**: 客户端收到了服务器的FIN报文。它会回复最后一个**确认报文段 (ACK=1)**，确认号为 `ack = v + 1`。
    *   **状态**: 客户端发送完毕后，进入 `TIME-WAIT` (时间等待) 状态。服务器收到这个ACK后，立即进入 `CLOSED` (关闭) 状态。
    *   **TIME-WAIT状态**: 客户端会在此状态等待 `2 * MSL` (Maximum Segment Lifetime，报文最大生存时间) 的时间。这是为了确保网络中所有可能迟到的、与此连接相关的报文段都已消失，并确保服务器一定能收到最后一个ACK（如果没收到，服务器会超时重传FIN，客户端可以再次响应）。`2MSL`结束后，客户端也进入 `CLOSED` 状态。
    *   **含义**: “好的，服务器，我也收到了你的关闭请求。再见！”

---

#### **4.5.3 TCP的状态变迁**

[返回目录](#toc-transport)

TCP连接的整个生命周期，可以通过一个复杂但精确的状态机来描述。上面提到的 `CLOSED`, `SYN-SENT`, `ESTABLISHED`, `FIN-WAIT-1`, `CLOSE-WAIT`, `TIME-WAIT` 等都是这个状态机中的状态。理解这个状态变迁图，对于深入排查网络问题非常有帮助。

---


### **4.6 TCP的可靠传输**

[返回目录](#toc-transport)

TCP的可靠传输机制是一个精妙的系统，它综合运用了多种技术来确保数据流的完整和有序。其核心是**以字节为单位的滑动窗口**。

#### **4.6.1 以字节为单位的滑动窗口**

[返回目录](#toc-transport)

TCP的滑动窗口机制可以看作是我们在“可靠传输原理”中学到的**连续ARQ协议**的一个高度优化的实现。

*   **基本概念**:
    *   **发送窗口**: 在发送端，TCP维护一个称为“发送窗口”的缓冲区。这个窗口覆盖了字节流中一段连续的、**已被发送但尚未收到确认**的字节，以及**允许被发送但尚未发送**的字节。
    *   **窗口大小**: 发送窗口的大小是**动态变化**的，它受到**接收方的接收能力（流量控制）**和**网络拥塞状况（拥塞控制）**的双重制约。
    *   **窗口滑动**: 当发送方收到接收方发来的新确认时，发送窗口的左边界就会向前“滑动”，使得更多新的数据可以被发送。

*   **发送窗口的三个关键指针**:
    1.  **SND.UNA (Send Unacknowledged)**: 指向已发送但**未被确认**的第一个字节的序号。这是发送窗口的**左边界**。
    2.  **SND.NXT (Send Next)**: 指向**下一个**将被发送的字节的序号。
    3.  **SND.WND (Send Window)**: 表示发送窗口的大小。

    窗口内的字节可以被发送，`SND.UNA` 左边的字节是已发送并已确认的，`SND.UNA + SND.WND` 右边的字节是还不能发送的。

*   **接收窗口**:
    *   在接收端，TCP也维护一个“接收窗口”，表示它当前愿意接收的数据的序号范围。
    *   它可以缓存失序到达、但序号落在窗口内的数据。
    *   当一段连续的数据被正确接收后，窗口会向前滑动，并通过TCP头部的“窗口大小”字段，将新的窗口大小通告给发送方。

*   **累计确认 (Cumulative Acknowledgement)**:
    *   TCP的ACK是**累计**的。一个 `ACK = N` 的确认号，意味着序号 `N-1` 之前的所有字节都已成功接收。
    *   **优点**: 即使中间有几个ACK丢失了，只要后面有一个更大的ACK到达，就可以一次性确认之前的所有数据，提高了确认效率。
    *   **缺点**: 无法向发送方提供“哪些数据到了，哪些没到”的精确信息，这可能导致不必要的重传。

#### **4.6.2 超时重传 (Timeout Retransmission)**
[返回目录](#toc-transport)
这是TCP处理**数据包丢失**最基本、也是最后的保障机制。

*   **工作原理**:
    1.  TCP发送方在发送一个报文段后，会启动一个**重传定时器 (Retransmission Timer)**。
    2.  如果在定时器超时之前，收到了对该报文段数据的确认，就关闭定时器。
    3.  如果定时器**超时**了，TCP就**假定**这个报文段已经在网络中丢失，并**重新发送**它。

*   **超时时间 (RTO - Retransmission Timeout) 的计算**:
    *   RTO的设置是TCP性能的关键，也是一个非常复杂的问题。
    *   **不能是固定的**: 因为网络延迟是动态变化的。设得太短，会造成不必要的重传；设得太长，又会增加丢包后的恢复时间。
    *   **动态自适应算法**: TCP通过持续测量**往返时间 (RTT - Round-Trip Time)**，并结合RTT的抖动（方差），来动态地计算出一个合理的RTO。这个算法通常被称为**Jacobson/Karels算法**。

#### **4.6.3 快速重传 (Fast Retransmit)**

[返回目录](#toc-transport)

超时重传虽然可靠，但**反应太慢**。有时数据包只是失序到达，而不是真的丢失，但发送方也可能要等待一个漫长的RTO超时后才重传。**快速重传**机制就是为了更快地检测和修复丢包而设计的。

*   **工作原理**:
    1.  TCP规定，接收方每收到一个**失序的**、但序号在期望值之后的报文段时，都必须**立即**发送一个对**期望序号的重复确认 (Duplicate ACK)**。
    2.  例如，接收方期望收到序号100，但却先收到了200、300、400。它会连续发送三次 `ACK=100`。
    3.  **触发条件**: 当发送方**连续收到三个**相同的重复ACK时（总共4个ACK，1个原始的，3个重复的），它就不再等待RTO超时，而是**立即“断定”**那个被重复确认的报文段（这里是序号100）已经丢失。
    4.  **动作**: 发送方会**立即重传**丢失的报文段（序号100），这个过程就是“快速重传”。

*   **优点**: 比等待RTO超时要快得多，能显著提高网络吞吐量。

#### **4.6.4 SACK重传 (Selective Acknowledgement)**

[返回目录](#toc-transport)

快速重传虽然快，但它仍然没有告诉发送方“到底哪些数据到了”。**SACK** 选项就是为了解决这个问题，它是对TCP确认机制的一个重要扩展。

*   **工作原理**:
    1.  在TCP连接建立时，双方可以通过`SACK-Permitted`选项协商启用SACK功能。
    2.  当接收方收到失序的数据时，它会在返回的重复ACK报文的**TCP选项**部分，附加上**SACK块**。
    3.  一个SACK块精确地描述了一段**已成功接收但不连续**的数据的边界。
    4.  例如，接收方期望100，但收到了200-299和400-499。它在返回 `ACK=100` 的同时，会附上SACK信息：`{SACK: 200-300, 400-500}`。
    5.  发送方收到这个带有SACK的ACK后，就精确地知道了：“100-199”和“300-399”这些数据块丢失了，而200-299和400-499已经安全到达。
    6.  这样，发送方就可以**选择性地、精确地**只重传那些真正丢失的数据块，而避免了不必要的重传。

*   **优点**: 这是最高效的重传机制，是现代高性能TCP实现（如CUBIC）的标准配置。

---


### **4.7 TCP的流量控制 (Flow Control)**

[返回目录](#toc-transport)

#### **1. 为什么需要流量控制？—— 核心动机**

可靠传输机制（如重传）确保了数据能“最终”到达，但它没有解决一个速度匹配的问题。

想象一下，发送方是一台性能强劲的服务器，而接收方可能是一台性能较弱的手机。如果发送方以极高的速度发送数据，远远超过了接收方的处理能力，会发生什么？

*   接收方的TCP**接收缓冲区 (Receive Buffer)** 会被迅速填满。
*   一旦缓冲区满了，后续到达的数据包将无处存放，只能被**丢弃**。
*   这些被丢弃的数据包，又会触发发送方的超时重传机制。
*   结果就是，发送方在不停地重传那些接收方根本无法处理的数据，造成了**网络资源的巨大浪费**和**传输效率的急剧下降**。

**流量控制 (Flow Control)** 的核心目标就是：**提供一种机制，让发送方的发送速率能够匹配接收方的接收速率，防止过快的数据流淹没接收方。**

**重要区别**:
*   **流量控制**: 解决的是**点对点**（发送方 vs. 接收方）的速度匹配问题，关心的是“接收方有多大肚子”。
*   **拥塞控制**: 解决的是**整个网络**的负载问题，关心的是“中间的路有多宽，是否堵车”。我们将在下一节讨论。

#### **2. 流量控制的实现机制：滑动窗口**

TCP巧妙地利用其**滑动窗口**机制来实现流量控制。具体来说，是利用TCP首部中的 **“窗口大小 (Window Size)”** 字段。

**工作原理**:

1.  **接收方通告接收能力**:
    *   在TCP连接的**接收端**，内核为其维护着一个接收缓冲区。
    *   接收方在向发送方发送**任何**一个ACK报文时（无论是确认数据还是在连接建立时），都会在TCP首部的“窗口大小”字段中，填入其**当前接收缓冲区的剩余空间大小**。
    *   这个值被称为**接收窗口 (rwnd - Receive Window)**。
    *   例如，如果接收方总缓冲区是4096字节，已经被应用层取走了2048字节，还剩2048字节，那么它就会在ACK报文中宣告 `Window Size = 2048`。

2.  **发送方动态调整发送速率**:
    *   发送方在收到这个ACK报文后，会提取出`rwnd`的值。
    *   发送方会保证自己**已发送但尚未被确认的数据量**，永远**不超过**接收方通告的`rwnd`值。
    *   这个`rwnd`值，就成了发送方**发送窗口**大小的一个**上限**。
    *   通过这种方式，发送方的发送行为被接收方的接收能力“死死地”控制住了。接收方处理得快，`rwnd`就大，发送方就能发得快；接收方处理得慢，`rw_nd`就小，发送方就必须减慢发送速度。

#### **3. 特殊情况：零窗口 (Zero Window) 和 持续定时器 (Persistence Timer)**

*   **问题：零窗口死锁**
    1.  接收方缓冲区满了，于是向发送方通告了一个 **`rwnd = 0`** 的窗口。
    2.  发送方收到后，停止发送数据。
    3.  一段时间后，接收方的应用程序从缓冲区读取了一些数据，缓冲区有了新的空间。
    4.  于是，接收方发送一个**更新窗口的ACK**（比如 `rwnd = 2048`）给发送方。
    5.  **关键问题**: 如果这个更新窗口的ACK报文在网络中**丢失**了，会发生什么？
    6.  **死锁**: 发送方将永远在等待一个非零窗口的通知，而接收方则在等待发送方发送新的数据。双方都在等待对方，通信就此挂起。

*   **解决方案：持续定时器 (Persistence Timer)**
    *   为了打破这种潜在的死锁，TCP为发送方设计了一个**持续定时器**。
    *   当发送方收到一个零窗口通知时，它会启动这个定时器。
    *   如果定时器超时，发送方会主动发送一个**窗口探测 (Window Probe)** 报文。这个报文通常只包含1个字节的数据。
    *   这个探测报文的作用，就是去“戳一下”接收方，**触发**接收方重新回复一个包含其**当前最新窗口大小**的ACK。
    *   只要这个探测报文能到达，接收方就必然会回复一个ACK。即使这个ACK再次丢失，持续定时器会再次超时，发送方会继续发送探测报文，直到收到一个非零窗口的ACK为止，从而打破死锁。

---


### **4.8 TCP的拥塞控制 (Congestion Control)**

[返回目录](#toc-transport)

#### **4.8.1 拥塞原因及其影响**

[返回目录](#toc-transport)

*   **什么是拥塞 (Congestion)？**
    *   当网络中**需求的总和**（所有主机想要发送的数据量）超过了网络中任何链路或路由器的**可用容量**时，拥塞就发生了。
    *   **比喻**: 就像早高峰时期的城市道路，想上路的汽车（数据包）太多，而道路容量（链路带宽）和路口处理能力（路由器处理能力）是有限的，于是就发生了堵车。

*   **拥塞的迹象**:
    1.  **分组丢失**: 路由器的输入缓冲区被填满后，后续到达的数据包只能被**丢弃 (Drop)**。这是网络发生拥塞最主要的信号。
    2.  **分组延迟增加**: 数据包在路由器的缓冲区中排队等待转发的时间变长。

*   **拥塞的恶性循环 (Congestion Collapse)**:
    *   如果不加控制，拥塞会自我加剧，形成恶性循环，最终可能导致**网络崩溃 (Congestion Collapse)**。
    *   **流程**:
        1.  少量拥塞导致分组丢失。
        2.  发送方（如TCP）发现丢包，进行**超时重传**。
        3.  这些重传的、重复的数据包，进一步增加了网络的负载。
        4.  网络负载加重，导致更严重的拥塞，引发更多的丢包。
        5.  更多的丢包又触发了更多的重传...如此循环，直到网络中充斥着大量重复的数据包，有效吞吐量急剧下降到接近于零。

**结论**: **拥塞控制是至关重要的**。它是一个**全局性**的问题，需要所有发送方共同协作，根据网络的承载能力来调节自己的发送速率，从而避免网络过载。

---

#### **4.8.2 TCP的经典拥塞控制**

[返回目录](#toc-transport)

TCP的拥塞控制是一个**端到端**的机制。发送方通过**观察网络状况（推断是否拥塞）**，来动态地调整自己的发送速率。它引入了一个新的状态变量：

*   **拥塞窗口 (Congestion Window, `cwnd`)**:
    *   `cwnd` 是发送方**自身**根据对网络拥塞的估算，而维护的一个窗口大小。它代表了在收到确认之前，发送方**可以向网络中连续发送**的数据量。
    *   **实际发送窗口 = min( `cwnd`, `rwnd` )**: 发送方最终的发送能力，同时受到**拥塞窗口（网络能力）**和**接收窗口（接收方能力）**的限制，取二者中的较小值。

TCP的经典拥塞控制算法主要由四个部分组成：**慢启动、拥塞避免、快速重传、快速恢复**。

**1. 慢启动 (Slow Start)**

*   **目标**: 在连接刚建立时，以一种**指数级增长**的方式，快速探测网络的可用带宽，找到网络的“大致容量”。
*   **算法**:
    *   初始时，`cwnd` 被设置为一个很小的值（通常是1个MSS，Maximum Segment Size）。
    *   每当发送方收到一个ACK确认时，`cwnd` 的值就 **增加1个MSS**。
    *   **效果**: 这相当于每经过一个RTT，`cwnd` 的大小就**翻倍** (1 -> 2 -> 4 -> 8 -> ...)。
*   **结束条件**: 慢启动并不是一直持续下去。当`cwnd`的值增长到-个预设的**慢启动阈值 (ssthresh - Slow Start Threshold)** 时，指数增长就会停止，算法进入下一个阶段——拥塞避免。

**2. 拥塞避免 (Congestion Avoidance)**

*   **目标**: 在已经接近网络容量时，以一种**线性、温和**的方式继续增加`cwnd`，以避免增长过快而冲垮网络。
*   **算法**:
    *   当`cwnd` ≥ `ssthresh`时，进入拥塞避免阶段。
    *   每经过一个RTT，`cwnd` 的值**只增加1个MSS** ( `cwnd = cwnd + 1` )。
*   **效果**: `cwnd` 此时呈**线性增长** (16 -> 17 -> 18 -> ...)，增长速度大大放缓。

**3. 拥塞事件的处理 (检测到丢包)**

当网络拥塞发生（即检测到丢包）时，TCP必须立刻“踩刹车”，减小`cwnd`。TCP通过两种方式来检测丢包：

*   **情况一：超时 (Timeout)** - (被认为是**严重拥塞**的信号)
    1.  将`ssthresh`的值**降为当前`cwnd`的一半** ( `ssthresh = cwnd / 2` )。
    2.  将`cwnd`的值**直接重置为1个MSS**。
    3.  **重新进入慢启动阶段**。
    *   这种处理方式非常激进，因为超时意味着网络状况已经非常糟糕。

*   **情况二：收到3个重复的ACK (Duplicate ACKs)** - (被认为是**轻微拥塞**的信号)
    *   此时触发**快速重传**和**快速恢复**算法。

**4. 快速恢复 (Fast Recovery)**

*   **目标**: 当通过重复ACK检测到丢包时，说明网络只是出现了轻微拥塞，后续的包还能正常到达。因此，没有必要像超时那样，将`cwnd`直接降到1，那样太保守了。
*   **算法 (TCP Reno版本)**:
    1.  将`ssthresh`的值**降为当前`cwnd`的一半** ( `ssthresh = cwnd / 2` )。
    2.  将`cwnd`的值也**直接设置为新的`ssthresh`** (而不是降为1)。
    3.  **立即进入拥塞避免阶段** (线性增长)。

**整个过程的动态图景**:
`cwnd`的大小会像“锯齿”一样动态变化：
*   **慢启动**: 指数增长。
*   **拥塞避免**: 线性增长。
*   **遇到丢包**:  резко下降。
*   然后再次开始新一轮的增长...
这个过程被称为 **AIMD (Additive Increase, Multiplicative Decrease - 加性增，乘性减)**，是TCP拥塞控制的核心思想。

---

#### **4.8.3 网络层辅助的拥塞控制 (拓展)**

[返回目录](#toc-transport)

传统的TCP拥塞控制完全是端到端的，中间的路由器不参与。现代网络提出了一些由网络层（路由器）辅助的拥塞控制机制。

*   **ECN (Explicit Congestion Notification - 显式拥塞通知)**:
    *   路由器在发现自己**即将**发生拥塞（比如缓冲区占用率超过某个阈值）时，并**不直接丢弃**数据包。
    *   而是在IP包头中设置一个“拥塞经历 (CE)”的比特位。
    *   接收端收到带有CE标记的包后，会在返回的ACK中设置一个ECN-Echo标志，来**明确地通知**发送方：“网络有点堵了，你最好慢一点”。
    *   发送方收到这个通知后，就会像收到重复ACK一样，主动降低`cwnd`。
    *   **优点**: 可以在**不丢包**的情况下，提前感知并应对拥塞。

---


### **拓展：TCP的定时器**

TCP协议的各种复杂机制，如连接管理、可靠传输、流量控制等，都离不开定时器的精确协作。TCP协议栈中主要有以下四种重要的定时器：

#### **1. 重传定时器 (Retransmission Timer)**

*   **作用**: 这是实现**超时重传**机制的核心，用于处理**数据包或ACK丢失**的情况。
*   **工作原理**:
    1.  当TCP发送一个包含了数据的报文段时，它会为这个报文段启动一个**重传定时器**。
    2.  如果在定时器超时之前，收到了对该报文段中数据的确认，定时器就会被取消。
    3.  如果定时器**超时**，TCP会假定该报文段已在网络中丢失，并**重新发送**它。
*   **关键**: 定时器的**超时时间 (RTO)** 是根据网络**往返时间 (RTT)** 动态计算的，以适应不同网络的延迟状况。

#### **2. 持续定时器 (Persistence Timer)**

*   **作用**: 专门用于解决**零窗口通告**可能导致的**死锁**问题。
*   **工作原理**:
    1.  当发送方收到接收方通告的一个大小为0的窗口时（`rwnd=0`），它会停止发送数据并启动**持续定时器**。
    2.  如果定时器超时，发送方会发送一个**窗口探测 (Window Probe)** 报文（通常只含1字节数据）。
    3.  这个探测报文的目的是**触发**接收方重新回复一个包含其当前最新窗口大小的ACK报文。
    4.  即使接收方窗口仍然为0，它也必须回复ACK。只要这个ACK不丢失，发送方就能重置持续定时器。这个过程会一直持续，直到发送方收到一个非零窗口的通知，从而打破死锁。

#### **3. 保活定时器 (Keepalive Timer)**

*   **作用**: 用于检测一个**长时间处于空闲状态**的TCP连接是否仍然有效（即对端主机是否崩溃或网络连接是否中断）。
*   **工作原理**:
    1.  当一个TCP连接上**长时间**（例如2小时）没有任何数据交互时，服务器端的TCP会启动**保活定时器**。
    2.  定时器超时后，服务器会向客户端发送一个**保活探测报文**。
    3.  服务器会连续发送多个探测报文（例如10个，每隔75秒一个）。
        *   如果收到了客户端的正常响应，说明连接仍然有效，就重置保活定时器。
        *   如果在发送完所有探测报文后，**仍然没有收到任何响应**，服务器就假定客户端已不再可达，并**关闭**这个连接，回收资源。
*   **注意**: 这个功能在很多操作系统中默认是关闭的，需要应用程序主动开启。

#### **4. 时间等待定时器 (TIME-WAIT Timer)**

*   **作用**: 用于TCP连接**正常释放**（四次挥手）的最后一个阶段，确保连接能够可靠地关闭。
*   **工作原理**:
    1.  在四次挥手过程中，**主动发起关闭**的一方（比如客户端），在发送完最后一个ACK报文后，会进入`TIME-WAIT`状态。
    2.  在此状态下，它会启动一个**时间等待定时器**，定时时长通常设置为 **2 * MSL** (Maximum Segment Lifetime - 报文最大生存时间，通常是2分钟)。
    3.  **设置该定时器的目的**:
        *   **保证最后一个ACK能到达对端**: 如果这个ACK丢失了，对端（服务器）会因为没收到ACK而超时重传它的FIN报文。处于`TIME-WAIT`状态的客户端仍然可以接收到这个重传的FIN，并重新发送ACK，从而确保服务器能够正常关闭。
        *   **防止已失效的报文段干扰新连接**: 等待2MSL可以确保在此连接中产生的所有报文段都已在网络中消失，从而避免这些“迷路”的旧报文段干扰后续可能使用相同端口号建立的新连接。
    4.  定时器超时后，连接才最终进入`CLOSED`状态。

---

