

---

### **5.1 网络层概述**

#### **5.1.1 传统网络的控制平面和数据平面**

要理解网络层的工作原理，首先必须理解网络设备（尤其是**路由器**）内部的两个核心功能平面：

1.  **数据平面 (Data Plane)**
    *   **核心功能**: **转发 (Forwarding)**。
    *   **工作内容**: 当一个数据包到达路由器的某个输入端口时，数据平面负责执行“查表-转发”这个**微观、快速、本地化**的动作。它根据数据包的目的IP地址，在本地的**转发表**中查找对应的输出端口，然后将数据包从输入端口快速交换到输出端口。
    *   **比喻**: 想象一个繁忙的十字路口的**交通警察**。他的任务就是看着来车的方向（目的地址），然后迅速地挥动旗帜，指挥车辆开往正确的出口（输出端口）。他只关心“这辆车，下一站去哪”，而不关心这辆车从哪里来，最终要到哪里去的全局路线。
    *   **实现**: 数据平面的功能通常由**硬件（专用芯片ASIC）** 实现，以达到线速（line-speed）转发的性能。

2.  **控制平面 (Control Plane)**
    *   **核心功能**: **路由 (Routing)**。
    *   **工作内容**: 控制平面负责执行“构建和维护转发表”这个**宏观、缓慢、全网性**的动作。它通过运行各种**路由选择协议**（如OSPF, BGP），与网络中其他的路由器交换路由信息，学习整个网络的拓
        *   **拓扑结构**，并最终计算出到达各个目的网络的**最佳路径**。
    *   控制平面计算出的结果——即“去往某个网络，下一跳该走哪里”——会被下发到数据平面，形成数据平面进行快速转发时所依据的**转发表**。
    *   **比喻**: 控制平面就像是城市交通规划局的**地图绘制和路线规划部门**。他们通过观察整个城市的交通流量（路由信息），使用复杂的算法（路由算法）来绘制地图，并为地图上的每个目的地都标明“最佳路线”（最佳路径）。然后，他们把这份“路线指南”（转发表）分发给每一个路口的交警（数据平面）。
    *   **实现**: 控制平面的功能通常由路由器内置的**CPU和软件**来执行。

**在传统网络中，控制平面和数据平面是紧密耦合、集成在同一台物理路由器设备里的。**

#### **5.1.2 软件定义网络的控制平面和数据平面**

**软件定义网络 (Software-Defined Networking, SDN)** 是近年来网络领域的一场革命。它的核心思想就是**将传统网络设备中紧密耦合的控制平面和数据平面分离开来**。

*   **SDN 架构**:
    1.  **数据平面**: 网络中的交换机/路由器被简化为纯粹的**“转发设备”**。它们只保留了高速的数据平面功能，不再运行复杂的路由协议。
    2.  **控制平面**: 所有网络设备的“大脑”（控制平面）被**集中**到一个外部的、基于软件的**SDN控制器 (Controller)** 上。
    3.  **南向接口 (Southbound Interface)**: SDN控制器通过一个开放的、标准的协议（如 **OpenFlow**），与数据平面的转发设备进行通信。控制器通过这个接口，向转发设备下发精确的流表（Flow Table），指导它们的转发行为。
    4.  **北向接口 (Northbound Interface)**: SDN控制器向上层应用提供**可编程的API**，使得网络管理员或应用程序可以通过编写代码，来实现对整个网络行为的自动化控制和管理。

*   **SDN的优势**:
    *   **集中式控制与全局视野**: 控制器拥有整个网络的拓扑视图，可以做出全局最优的决策，而不是像传统网络那样每个路由器都只能“各自为政”。
    *   **网络可编程性**: 将网络能力以API的形式开放出来，使得网络管理和创新变得像软件开发一样灵活、快速。
    *   **简化网络设备**: 转发设备变得更简单、更廉价，因为它们不再需要昂贵的CPU和复杂的软件。
---

### **一个全局的例子：你访问 `www.google.com`**

**参与角色**:
*   **你的电脑**: 运行着浏览器（应用层）、TCP协议（传输层）、IP协议（网络层）等。
*   **你的家庭路由器**: 连接你家和ISP的设备。
*   **ISP网络中的多个路由器**: R1, R2, R3...
*   **Google的服务器**: 运行着Web服务器软件。

---

### **第一阶段：准备工作 —— 控制平面的“幕后布局”**

在我们开始访问网页之前，甚至在你打开电脑之前，整个互联网的**控制平面**就已经在“默默地”工作了。这个阶段是宏观的、缓慢的、全局性的。

**1. 路由协议的运行 (控制平面的核心)**
*   **场景**: 在ISP的网络中，R1, R2, R3等所有路由器，都在运行着一个**内部网关路由协议**，比如 **OSPF**。
*   **动作 (控制平面)**:
    *   R1会告诉R2和R3：“你好，我是R1，我直接连接着网络A和网络B。”
    *   R2也会告诉R1和R3：“你好，我是R2，我直接连接着网络C和网络D。”
    *   通过不断地交换这类“链路状态”信息，网络中**每一个路由器**的**控制平面**（也就是它们各自的CPU和路由软件），最终都在自己的脑海里构建出了一张**完整的ISP网络拓扑地图**。
*   **结果 (构建路由表)**:
    *   基于这张地图，每个路由器的控制平面会使用一个算法（如Dijkstra算法），计算出从自己出发，到达ISP网络内**所有其他网络**的**最短路径**。
    *   例如，R1的控制平面计算出：“要去往网络D，最短的路径是先把包发给R2。”
    *   这个计算结果，就被写入到R1的**路由表**中。

**2. BGP的运行 (跨网络)**
*   ISP的边界路由器，还会通过**BGP协议**（一种外部网关协议）与Google等其他网络的边界路由器交换信息。
*   ISP的控制平面会学习到：“要去往Google的服务器所在的网络（比如 `142.250.0.0/16`），下一跳应该发给某个国际出口路由器。” 这条信息同样会被写入路由表。

**至此，控制平面的主要工作已经完成。它为整个互联网构建了一张巨大的、可达的“交通地图”（所有路由器的路由表集合）。这个过程是持续的、动态的，但相对数据转发来说是缓慢的。**

---

### **第二阶段：数据传输 —— 数据平面的“闪电转发”**

现在，你打开浏览器，输入 `www.google.com`，按下了回车。

**1. 你的电脑上的操作 (应用层 -> 传输层 -> 网络层)**
*   **应用层**: 浏览器需要知道 `www.google.com` 的IP地址，于是发起**DNS查询**（应用层）。
*   **传输层**: DNS查询被打包成一个**UDP**数据报，并分配一个源端口号。
*   **网络层**: UDP数据报被交给IP协议，封装成一个**IP数据包**，源IP是你电脑的IP，目的IP是DNS服务器的IP。
    *   电脑的网络层会查询自己的**路由表**，发现要去往外部网络，需要把包发给**默认网关**（你的家庭路由器）。

**2. 数据包的旅程 (数据平面的核心)**
*   **第一跳：你的家庭路由器**
    *   数据包到达你的家庭路由器。
    *   **数据平面 (Hardware ASIC)** 接管：
        1.  **查表**: 路由器的硬件芯片提取出数据包的目的IP（DNS服务器的IP）。
        2.  **匹配**: 在路由表中快速查找，匹配到默认路由（`0.0.0.0/0`），该路由指向ISP的下一个路由器（R1）。
        3.  **转发**: 硬件将数据包从你的家庭局域网接口，快速交换到连接ISP的广域网接口，并发往R1。
    *   **注意**: 这个过程极快，通常在微秒级别完成，完全由硬件处理。路由器的**CPU（控制平面）在此刻是空闲的**，它不需要参与这个转发决策。

*   **第二跳、第三跳... ISP内的路由器 (R1, R2...)**
    *   数据包到达R1。
    *   **R1的数据平面**重复上述过程：查表 -> 匹配 -> 转发。它根据之前由**控制平面**计算好的路由表，将数据包发往下一跳R2。
    *   数据包到达R2，**R2的数据平面**继续...
    *   这个过程就像接力赛，每个路由器的**数据平面**都只负责自己这一棒的快速传递，它们完全依赖于**控制平面**事先规划好的路线。

**3. 得到IP，发起HTTP请求**
*   最终，DNS响应包原路返回，你的电脑知道了Google服务器的IP地址（比如 `142.250.187.164`）。
*   浏览器现在发起HTTP请求。
*   **应用层**: 生成HTTP GET请求。
*   **传输层**: 建立**TCP连接**（三次握手），然后将HTTP请求打包成TCP报文段。
*   **网络层**: 封装成IP数据包，源IP是你电脑，目的IP是 `142.250.187.164`。
*   这个HTTP请求的数据包，会再次踏上由各个路由器**数据平面**构成的“高速公路”，被一跳一跳地快速转发到Google的服务器。

---

### **软件定义网络 (SDN) 的区别**

在SDN世界里，这个流程会变成：

*   **幕后布局 (控制平面)**:
    *   ISP的所有路由器（现在是简单的转发设备）都连接到一个**中央SDN控制器**。
    *   这个控制器拥有上帝视角，它知道整个网络的全貌。
    *   **控制器**计算出所有最佳路径，然后通过OpenFlow协议，将精确的转发规则（流表）**下发并安装**到每一个转发设备的**数据平面**中。

*   **数据传输 (数据平面)**:
    *   你的数据包到达第一个转发设备。
    *   该设备的**数据平面**不再查询传统的路由表，而是查询由控制器下发的**流表**。
    *   流表的匹配规则可以更复杂（比如可以根据源IP、目的端口号等），但核心动作依然是：**匹配 -> 执行动作（转发到某个端口）**。
    *   整个转发过程依然由硬件高速完成，但“大脑”已经从每个设备中移出，集中到了控制器那里。

**总结**:
*   **控制平面 (路由选择)**: 像一个城市的**交通规划局**，负责**提前规划**好所有路线，并绘制成“指导手册”（路由表）。这是一个**慢速、全局性**的决策过程。
*   **数据平面 (分组转发)**: 像路口的**交警**，他**不负责规划**路线，只负责严格按照“指导手册”，**快速地指挥**每一辆过往的车辆。这是一个**高速、本地化**的执行过程。

---
#### **5.1.3 本章的主要协议**

网络层包含了一系列重要的协议，它们共同协作，完成了数据包的寻址、路由和转发。本章我们将重点学习：

*   **IP (Internet Protocol - 网际协议)**: 网络层的核心协议，负责定义数据包的格式（IP数据报）、寻址方式以及路由的基本原则。
*   **ICMP (Internet Control Message Protocol - 网际控制报文协议)**: IP协议的“助手”，负责在IP网络中传递差错报告和控制信息。
*   **路由选择协议 (Routing Protocols)**:
    *   **内部网关协议 (Interior Gateway Protocol, IGP)**: 在一个**自治系统 (AS)** 内部使用的路由协议，如 **RIP**, **OSPF**。
    *   **外部网关协议 (Exterior Gateway Protocol, EGP)**: 在不同的**自治系统**之间交换路由信息的协议，如 **BGP**。

---


### **5.2 互联网协议 (IP)**

#### **5.2.1 互联网协议概述**

**IP (Internet Protocol)** 是TCP/IP协议栈网络层的核心协议。你可以把它想象成整个互联网的“全球邮政系统”。它定义了邮件（数据包）的标准化信封格式，以及全球唯一的地址系统，但它本身不保证邮件一定能送达。

**IP协议的核心特征**:

1.  **无连接 (Connectionless)**
    *   IP协议在发送数据包之前，**不需要**在源主机和目的主机之间建立任何连接。
    *   每个IP数据报（也常被称为**分组 (Packet)**）都是一个独立的、与其他数据报无关的单元。
    *   发送方可以随时将数据报发送出去，网络中的路由器会对每个数据报**独立地**进行路由决策。
    *   **结果**: 这可能导致同一个会话的多个数据包，通过不同的路径到达目的地，从而产生**失序**。

2.  **不可靠 / 尽力而为 (Unreliable / Best-Effort)**
    *   IP协议是**不可靠的**。它不提供任何机制来保证数据包的可靠交付。
    *   **“尽力而为”** 是对它服务模型的最好描述。IP协议会尽其所能地将数据包向目的地转发，但它**不保证**:
        *   数据包一定能到达（可能会因网络拥塞、TTL耗尽、校验和错误等原因被丢弃）。
        *   数据包不重复。
        *   数据包按序到达。
    *   **可靠性**的重担，完全交给了**上层的传输层**（如TCP协议）去解决。

#### **5.2.2 IP数据报格式 (IPv4)**

一个IP数据报由**首部 (Header)** 和 **数据部分 (Payload)** 组成。数据部分通常是来自传输层的TCP报文段或UDP数据报。

IP首部的格式相对复杂，**固定部分为20字节**，后面可以跟最多40字节的选项字段。


<img width="705" height="396" alt="image" src="https://github.com/user-attachments/assets/586bd7ca-aa9f-41f9-a4ff-a86169970aa5" />



**IP首部关键字段详解**:

*   **版本 (Version, 4位)**: 指明IP协议的版本。对于IPv4，此值为 **4**。

*   **首部长度 (IHL - Internet Header Length, 4位)**:
    *   表示整个IP首部的长度，单位是 **4字节**。
    *   由于有可变长的选项，所以需要这个字段。
    *   最小值为5 (`5 * 4 = 20`字节，即没有选项)，最大值为15 (`15 * 4 = 60`字节)。
   
*   **差分服务代码点 (Differentiated Services Code Point, DSCP) - (6位)**:
    *   DSCP值用来对数据包进行分类和标记。网络管理员可以在网络边界的路由器上配置策略，根据不同的DSCP值，为数据包提供不同的转发行为 (Per-Hop Behavior, PHB)。
    *   DSCP值就像是贴在包裹上的不同标签：“次日达”、“加急”、“普通快递”、“平邮”。
    *   转发行为 (PHB): 沿途的每一个分拣中心（路由器），看到“次日达”标签的包裹，就会优先处理它，把它放进最快的运输队列；看到“平邮”标签的，就可能会让它多等一会儿。
    *   常见DSCP值:
    *   *   EF (Expedited Forwarding): 加急转发。用于VoIP等需要极低延迟和抖动的实时业务。
        *   AF (Assured Forwarding): 确保转发。分为4个类别，每个类别有3个丢弃优先级，提供不同等级的保障服务。
        *   BE (Best-Effort): 尽力而为。默认值，即普通互联网流量。

*   **显式拥塞通知 (Explicit Congestion Notification, ECN) - (2位)**:
    *   正如我们在TCP拥塞控制中提到的，ECN是一种路由器与端系统协作的主动拥塞管理机制。它允许路由器在不丢包的情况下，向数据流的发送方显式地通知网络即将发生拥塞。
    *   2个比特位的含义:
    *   *   00: 不支持ECN的传输。
        *   01 或 10: 支持ECN的端点设置的，表示愿意参与ECN过程。
        *   11: 由拥塞的路由器设置的，表示**“拥塞已经发生 (Congestion Experienced, CE)”**。
    *   流程:

```
发送方在IP包头中将ECN位设置为01或10，表示“我支持ECN”。
当这个包经过一个缓冲区即将满的路由器时，路由器不会丢弃它，而是将ECN位修改为11。
接收方收到这个ECN位为11的包后，知道路上发生了拥塞。
接收方会在返回的ACK报文（在TCP头部或IP头部）中设置一个标志，将这个拥塞信号回传给发送方。
发送方收到这个拥塞通知后，就会像检测到丢包一样，主动降低自己的拥塞窗口，从而缓解网络压力。

```
*   **总长度 (Total Length, 16位)**:
    *   表示整个IP数据报（首部 + 数据部分）的总长度，单位是字节。
    *   16位意味着一个IP数据报最大可以是 `2^16 - 1 = 65535` 字节。

*   **标识 (Identification, 16位)**, **标志 (Flags, 3位)**, **片偏移 (Fragment Offset, 13位)**:
    *   这三个字段共同用于IP数据报的**分片与重组 (Fragmentation and Reassembly)**。
    *   **背景**: 当一个大的IP数据报要通过一个**最大传输单元 (MTU)** 较小的网络时（比如以太网的MTU通常是1500字节），它必须被**分片**成多个较小的数据报才能通过。
    *   **标识**: 属于同一个原始数据报的所有分片，都具有**相同的标识号**。
    *   **标志**:
        *   `DF (Don't Fragment)`位: 如果置1，表示禁止对该数据报进行分片。
        *   `MF (More Fragments)`位: 除了最后一个分片，其他所有分片都将此位置1。
    *   **片偏移**: 指明该分片的数据部分，在原始数据报的数据部分中的**起始位置**。

*   **生存时间 (Time to Live, TTL, 8位)**:
    *   一个数据包在网络中允许存活的“跳数”上限。
    *   每经过一个路由器，该路由都会将TTL的值**减1**。
    *   当TTL**减到0**时，路由器会丢弃这个数据包，并通常会向源主机发送一个ICMP“超时”差错报告。
    *   **核心作用**: 防止数据包因路由错误而在网络中**无限循环**，耗尽网络资源。

*   **协议 (Protocol, 8位)**:
    *   指明此IP数据报的数据部分，应该交付给**上层的哪个协议**来处理。
    *   这是一个非常关键的“分用”字段。
    *   常见的值：**6 (TCP)**, **17 (UDP)**, **1 (ICMP)**。

*   **首部校验和 (Header Checksum, 16位)**:
    *   **只检验IP首部**，不检验数据部分。
    *   每经过一个路由器，由于TTL等字段会改变，路由器都**必须重新计算**并更新这个校验和。

*   **源IP地址 (Source IP Address, 32位)**: 发送方的IP地址。

*   **目的IP地址 (Destination IP Address, 32位)**: 接收方的IP地址。这是路由器进行转发决策的主要依据。

---


### **5.3 IP分组转发**

当一个IP数据报到达路由器时，路由器的数据平面需要快速做出决策：**“这个数据包的下一跳应该去哪里？”** 这个决策过程就是分组转发。它依赖于一个关键的数据结构——**路由表**。

#### **5.3.1 路由表 (Routing Table)**

*   **是什么？**
    路由表是存储在路由器内存中的一个**数据库**，它记录了到达**各个目的网络**的**路径信息**。路由表是由路由器的**控制平面**通过各种方式（静态配置或动态路由协议）构建和维护的。

*   **路由表的结构**:
    一个简化的路由表通常包含以下几个关键列：

| 目的网络 (Destination) | 子网掩码 (Netmask) | 下一跳 (Next Hop) | 接口 (Interface) | 度量 (Metric) |
| :--- | :--- | :--- | :--- | :--- |
| `192.168.1.0` | `255.255.255.0` | `On-link` / `Directly Connected` | `eth0` | 0 |
| `10.0.0.0` | `255.0.0.0` | `192.168.1.254` | `eth0` | 20 |
| `0.0.0.0` | `0.0.0.0` | `202.10.10.1` | `wan0` | 100 |

*   **字段解释**:
    *   **目的网络**: 目标IP地址所属的网络地址。
    *   **子网掩码 (或前缀长度)**: 与目的网络地址一起，定义了一个地址范围。
    *   **下一跳**: 要到达目的网络，数据包**下一个**应该被发往的**路由器的IP地址**。如果目的网络是与本路由器**直接相连**的，则显示为 `Directly Connected`。
    *   **接口**: 数据包应该从本路由器的**哪个物理端口**（如 `eth0`, `wan0`）发送出去。
    *   **度量 (Metric)**: 一个表示路径“成本”或“优劣”的数值。当到达同一个目的网络有多条路径时，路由器会选择度量值**最低**的那条路径。

#### **5.3.2 分组转发算法**

路由器的数据平面在收到一个IP数据报后，会严格按照以下算法进行转发：

**第一步：提取目的IP地址**
*   路由器从收到的IP数据报首部中，提取出 **目的IP地址 (Destination IP Address)**。

**第二步：查找路由表 (最长前缀匹配)**
*   路由器会用这个目的IP地址，去**逐条匹配**路由表中的“目的网络”条目。
*   匹配规则是：`(目的IP地址) AND (条目的子网掩码) == (条目的目的网络地址)`
*   **关键原则 - 最长前缀匹配 (Longest Prefix Match)**:
    *   一个目的IP地址**可能**会同时匹配路由表中的**多条**路由。
    *   例如，去往 `35.230.35.10` 的数据包，可能会同时匹配 `35.230.32.0/21` 和 `35.230.0.0/16` 这两条路由。
    *   在这种情况下，路由器**永远选择**那个**前缀长度最长**（即子网掩码中1的位数最多、网络范围更具体、更精确）的路由。
    *   在这个例子中，路由器会选择 `/21` 这条路由，因为它比 `/16` 更长、更具体。
*   **默认路由 (Default Route)**:
    *   如果路由器在表中找不到任何匹配的、更具体的路由条目，它就会匹配**最后一条**特殊的路由——**默认路由** (`0.0.0.0/0`)。
    *   默认路由的前缀长度为0，因此它是“最短”的匹配，只有在别无选择时才会被使用。它通常指向该网络的“出口网关”。

**第三步：处理数据包**
1.  **TTL减1**: 路由器将IP数据报首部的 **TTL (生存时间) 字段的值减1**。
    *   如果TTL减为0，路由器会**丢弃**该数据包，并向源主机发送一个ICMP“超时”差错报告。
    *   如果TTL大于0，则继续。
2.  **重新计算首部校验和**: 因为TTL字段发生了变化，路由器**必须**重新计算IP首部的校验和，并更新该字段。

**第四步：封装并转发**
1.  **确定下一跳的MAC地址**: 路由器已经从路由表中知道了下一跳的IP地址和出接口。现在，它需要将这个IP数据包封装进一个**数据链路层的帧**（如以太网帧）中。这需要知道下一跳设备的**物理MAC地址**。
    *   路由器会查询自己的**ARP缓存表**，看是否有下一跳IP地址对应的MAC地址。
    *   如果没有，它会通过**ARP协议**在出接口所在的网络上发送广播，来获取该MAC地址。
2.  **封装成帧**: 将IP数据包作为数据部分，加上目的MAC地址（下一跳的MAC）和源MAC地址（出接口的MAC），封装成一个以太网帧。
3.  **发送**: 将这个帧通过指定的物理接口发送出去。

至此，一个数据包在路由器中的转发过程就完成了。

---

### **拓展：IPv6**

IPv6是为解决IPv4地址耗尽等问题而设计的下一代IP协议。

*   **主要特点**:
    1.  **巨大的地址空间**: 从32位扩展到 **128位**，地址数量近乎无限。
    2.  **简化的首部**: 移除了一些不必要的字段（如校验和、IHL），并将选项字段改为扩展首部，使得路由器处理效率更高。
    3.  **取消了分片**: IPv6要求端到端路径上的所有设备都支持一个合理的最小MTU，中间路由器不再进行分片，分片只能在源主机进行。
    4.  **增强的安全性**: **IPsec** 被设计为IPv6的强制组成部分。
    5.  **更好的移动性支持**: 内置了对移动IP的支持。

*   **IPv4到IPv6的过渡技术**: 由于不可能在一夜之间完成全球网络的升级，因此采用了多种过渡技术，如**双协议栈 (Dual Stack)** 和 **隧道技术 (Tunneling)**。

---
