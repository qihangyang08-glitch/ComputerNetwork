

---

### **4.1 传输层概述**

#### **4.1.1 传输层的两个重要协议**

传输层为应用层提供了两种截然不同、但都至关重要的服务。这两种服务分别由两个核心协议来提供：

1.  **TCP (Transmission Control Protocol - 传输控制协议)**
    *   **服务类型**: **面向连接的、可靠的** 数据传输服务。
    *   **核心特征**:
        *   **面向连接 (Connection-oriented)**: 在传输数据之前，通信双方的TCP协议栈必须先建立一个虚拟的连接（“三次握手”）。所有数据都在这个连接上传输，传输结束后再释放连接（“四次挥手”）。
        *   **可靠性 (Reliable)**: TCP提供了一整套复杂的机制来确保数据传输的可靠性。它保证：
            *   **无差错**: 通过校验和机制，丢弃损坏的数据包。
            *   **不丢失**: 通过确认和超时重传机制，确保丢失的数据包能被重发。
            *   **不重复**: 通过序号机制，丢弃重复的数据包。
            *   **按顺序**: 通过序号机制，对失序到达的数据包进行重新排序。
        *   **全双工通信**: 连接建立后，双方可以同时进行数据的发送和接收。
        *   **流量控制 (Flow Control)**: 控制发送方的发送速率，防止过快的数据淹没接收方。
        *   **拥塞控制 (Congestion Control)**: 感知网络拥塞状况，动态调整发送速率，避免造成网络崩溃。
    *   **应用场景**: 适用于对数据**完整性和顺序**有严格要求的应用，如**网页浏览(HTTP)、文件传输(FTP)、电子邮件(SMTP)**。

2.  **UDP (User Datagram Protocol - 用户数据报协议)**
    *   **服务类型**: **无连接的、不可靠的** 数据传输服务。
    *   **核心特征**:
        *   **无连接 (Connectionless)**: 发送数据前不需要建立连接，想发就发。每个数据报（Datagram）都是一个独立的、与其他数据报无关的单元。
        *   **不可靠 (Unreliable)**: UDP奉行**“尽力而为 (Best-effort)”** 的原则。它不保证数据能成功到达，不保证按序到达，也不保证不重复。如果数据包在传输中丢失、损坏或失序，UDP协议本身**不采取任何措施**。
        *   **开销小，速度快**: 正因为它省去了所有保证可靠性的复杂机制，所以它的协议头部非常小（仅8字节），处理速度极快。
        *   **面向报文**: UDP保留了应用层消息的边界。应用层交下来一个多大的数据块，UDP就给它加上头部，原封不动地发出去。
    *   **应用场景**: 适用于对**实时性**要求高、能容忍少量丢包的应用，如**域名解析(DNS)、动态主机配置(DHCP)、实时视频流、在线游戏、网络电话(VoIP)**。

#### **4.1.2 传输层复用、分用和端口**

这是传输层最基本、也是最重要的功能。

*   **问题**: 网络层（IP协议）只负责将数据包从**源主机**送到**目的主机**。但一台主机上可能同时运行着多个需要联网的应用程序（浏览器、微信、游戏等）。当一个数据包到达目的主机时，操作系统内核的网络协议栈如何知道应该把这个数据包交给哪个应用程序呢？

*   **解决方案**: **端口号 (Port Number)**。

    *   **端口号**: 一个16位的数字（范围0-65535），用于在**一台主机**内部标识一个特定的**应用程序进程**。
    *   **复用 (Multiplexing)**: 在**发送端**，传输层（TCP或UDP）从多个不同的应用进程（通过不同的端口号标识）收集数据，为它们分别封装上正确的端口号信息，然后将这些数据段（Segments）或数据报（Datagrams）一同传递给下层的网络层。这就好像一个邮局的收件员，从不同的人（应用进程）手里收集信件，装进同一个邮袋里发出去。
    *   **分用 (Demultiplexing)**: 在**接收端**，传输层根据收到的数据段或数据报头部的**目的端口号**，来决定应该将数据交付给哪个上层应用程序。这就好像邮局的派件员，根据信封上的“房间号”（端口号），把信准确地投递到对应的住户（应用进程）手里。

*   **套接字 (Socket)**:
    *   一个完整的网络通信连接，是由一个**五元组**来唯一标识的：
        `{传输层协议, 源IP地址, 源端口号, 目的IP地址, 目的端口号}`
    *   这个五元组定义了一个唯一的套接字对，确保了即使同一个主机上的同一个应用程序（比如浏览器打开了多个标签页），它们各自的通信也不会混淆。

---


### **4.2 用户数据报协议 (UDP)**

#### **4.2.1 用户数据报协议概述**

**UDP (User Datagram Protocol)** 是TCP/IP协议栈中与TCP并列的另一个核心传输层协议。它提供了一种极其简单的、**无连接的、不可靠的**数据报服务。

**UDP的核心设计哲学：简单、快速、尽力而为。**

*   **“无连接”的含义**:
    *   UDP在发送数据之前，**不需要**像TCP那样先通过“三次握手”建立连接。
    *   发送方可以随时将数据打包成UDP数据报并发送出去，就像寄平信一样，写好地址就扔进邮筒，不用先打电话确认对方是否在家。
    *   每个UDP数据报都是一个独立的单元，在网络中被独立地路由，它们之间没有上下文关系。

*   **“不可靠”的含义**:
    *   UDP不提供任何可靠性保证。它只是简单地将应用层的数据加上UDP头部，然后就“尽最大努力”地交给下层的IP协议去传输。
    *   它**不保证**：
        *   数据报一定能到达目的地（可能会在网络中丢失）。
        *   数据报的到达顺序与发送顺序一致（可能会失序）。
        *   数据报在传输过程中没有损坏（虽然有校验和，但出错的数据报通常只是被静默丢弃）。
    *   **可靠性必须由上层应用自己来保证**。如果应用需要可靠传输，就必须自己在程序中实现确认、重传等逻辑（QUIC协议就是这么做的）。

*   **UDP的优点**:
    1.  **开销小，速度快**: 因为没有复杂的连接管理、确认、重传、流量控制等机制，UDP的协议头部非常小，处理速度非常快。
    2.  **支持一对一、一对多、多对一、多对多的交互通信**: 由于其无连接的特性，非常灵活。
    3.  **保留应用消息边界**: UDP是面向报文的。应用层给UDP一个100字节的消息，UDP就发送一个100字节的数据报；应用层给一个20字节的消息，UDP就发一个20字节的数据报。它不会像TCP那样将数据合并或拆分。

#### **4.2.2 UDP用户数据报格式**

UDP的数据单元称为**用户数据报 (User Datagram)**。它的结构分为两部分：**UDP首部 (Header)** 和 **UDP数据区 (Payload)**。

UDP的首部格式极其简单，是固定的 **8个字节 (64位)**。

```
  0      7 8     15 16    23 24    31
 +--------+--------+--------+--------+
 |     Source      |   Destination   |
 |      Port       |      Port       |
 +--------+--------+--------+--------+
 |     Length      |    Checksum     |
 +--------+--------+--------+--------+
 |
 |          data payload ...
 |
 +---------------- ...

```

**UDP首部字段详解**:

*   **源端口 (Source Port, 16位)**
    *   标识发送方应用程序进程的端口号。
    *   这个字段是**可选的**。对于一个只发送数据而不需要接收响应的单向通信应用，源端口可以全置为0。但在大多数情况下（如DNS查询），客户端会填上自己的端口，以便服务器能将响应发回。

*   **目的端口 (Destination Port, 16位)**
    *   标识接收方应用程序进程的端口号。
    *   这个字段是**必须的**。

*   **长度 (Length, 16位)**
    *   该字段指定了整个UDP用户数据报的**总长度**，单位是字节。
    *   总长度 = UDP首部长度 (8字节) + UDP数据区长度。
    *   16位意味着UDP数据报的最大长度是 `2^16 - 1 = 65535` 字节。但由于下层IP协议的限制，实际能传输的数据通常要小得多（约65507字节）。

*   **校验和 (Checksum, 16位)**
    *   用于检测UDP用户数据报在传输过程中是否出现了**差错**（比如比特翻转）。
    *   这个字段是**可选的**。在IPv4中，如果发送端没有计算校验和，则该字段全置为0。但在IPv6中，校验和是**强制**的。
    *   **计算范围**: 校验和的计算不仅包括UDP首部和数据区，还包括一个从IP数据包头部提取出来的“伪首部”（包含源/目的IP地址、协议号等信息）。将IP地址包含进来，可以防止数据报被错误地路由到其他主机后还能校验通过。
    *   **差错处理**: 如果接收端计算出的校验和与该字段的值不符，就认为数据报在传输中损坏了，会**静默地丢弃**这个数据报，**不会**通知发送方。

---


### **通信模式：单播、广播、多播**

首先，我们来定义这三种通信模式。它们描述的是一个数据包从“一个源”出发后，最终期望被“多少个目标”接收。

**1. 单播 (Unicast)**

*   **定义**: **一对一 (One-to-One)** 的通信。数据包从一个唯一的源地址，被发送到一个唯一的目的地址。
*   **特征**: 网络中的路由器会根据目的地址，为这个数据包寻找一条精确的路径，最终只将其投递给唯一的目标主机。
*   **比喻**: **打电话**。你拨打一个特定的号码，只有那个号码对应的电话会响。
*   **应用**: 这是互联网上**最常见**的通信模式，我们日常的网页浏览(HTTP)、文件下载(FTP)、收发邮件(SMTP/POP3/IMAP)等，全部都是单播。

**2. 广播 (Broadcast)**

*   **定义**: **一对所有 (One-to-All)** 的通信。数据包从一个源地址，被发送到一个子网内的**所有**主机。
*   **特征**: 广播通常被限制在一个**广播域**（通常是一个局域网）内，**路由器默认不会转发广播包**，以防止广播风暴淹没整个互联网。广播使用一个特殊的目的地址（如 `255.255.255.255` 或子网广播地址 `192.168.1.255`）。
*   **比喻**: **大喇叭喊话**。你在一个办公大厅里用大喇叭喊话，大厅里的所有人都能听到。
*   **应用**: 主要用于局域网内的**服务发现**，比如**DHCP**客户端寻找DHCP服务器，或者**ARP**协议寻找IP地址对应的MAC地址。

**3. 多播 (Multicast) / 组播**

*   **定义**: **一对一组 (One-to-Many)** 的通信。数据包从一个源地址，被发送到一个特定的“多播组”地址。只有**主动加入了这个组**的主机，才会收到这份数据包。
*   **特征**:
    *   **高效性**: 发送者只需发送一份数据，网络中的路由器会负责在必要的分叉点对数据包进行**复制和分发**，只将数据投递给那些下游有组成员的网络链路上。这极大地节省了服务器的带宽。
    *   **选择性**: 不像广播那样强制所有人都接收，多播允许主机自由选择加入或离开一个组。
*   **比喻**: **订阅杂志/邮件列表**。只有订阅了某份杂志的人，才会收到这份杂志。
*   **应用**: **在线视频直播**、**网络电视 (IPTV)**、**多人视频会议**、**在线多人游戏**、**金融市场数据分发**等。

---

### **TCP 和 UDP 对这三种模式的支持情况**

现在，我们来看TCP和UDP这两个传输层协议如何与这三种通信模式相结合。

**1. UDP (用户数据报协议)**

UDP是无连接的、轻量级的协议，这使得它非常灵活。

*   **支持单播 (Unicast)**: **支持**。这是UDP的常规用法。例如，DNS查询就是一个典型的UDP单播应用。

*   **支持广播 (Broadcast)**: **支持**。DHCP和ARP（虽然ARP工作在网络层和数据链路层之间，但其广播发现的理念与此类似）就是利用广播来寻找服务器。

*   **支持多播 (Multicast)**: **大力支持**。可以说，UDP是实现多播应用的**首选和标准**传输层协议。几乎所有我们上面提到的多播应用（视频流、在线游戏等），其数据流都是通过UDP来承载的。因为这些应用通常对实时性要求很高，能容忍少量丢包，这与UDP的特性完美契合。

**总结：UDP 支持 单播、广播、多播。**

**2. TCP (传输控制协议)**

TCP是面向连接的、可靠的协议，这个核心特性决定了它对通信模式的支持。

*   **支持单播 (Unicast)**: **大力支持**。TCP的设计初衷就是为了提供**点对点**的、可靠的单播通信。所有基于TCP的应用，如HTTP、FTP、SMTP等，都是单播应用。

*   **支持广播 (Broadcast)**: **不支持**。
    *   **原因**: TCP的**核心是“连接”**。建立一个TCP连接需要**三次握手**，这个过程必须在**两个明确的端点**之间进行。而广播的目的地址是“网络中的所有人”，它不是一个明确的端点，你无法与“所有人”同时进行三次握手并建立一个可靠的连接。

*   **支持多播 (Multicast)**: **不支持**。
    *   **原因**: 与广播类似，多播的目的地址是一个“组”，而不是一个单一的端点，因此无法进行TCP的三次握手。此外，TCP的**可靠性机制**（确认、重传、流量控制）在多播场景下会变得极其复杂且低效。
        *   想象一下，如果一个多播组里有1000个接收者，其中999个都收到了包，只有1个没收到。发送方是否要为了这1个人，向所有人重传？还是只给那1个人重传？如果同时有几十个人丢了不同的包，发送方就会被大量的确认和重传请求（ACK风暴）所淹没。
        *   因此，TCP的可靠模型与多播的“一对多”模型在根本上是**不兼容**的。

**总结：TCP 只支持 单播。**

---



### **4.3 可靠传输原理**

我们已经知道，UDP提供的是不可靠的传输，而TCP提供的是可靠的传输。那么，“可靠性”究竟是如何实现的呢？

网络层的IP协议是不可靠的，它可能会导致数据包**出错（比特翻转）、丢失、重复或失序**。可靠传输协议的目标，就是在这样一条不可靠的信道上，构建出一个对上层应用来说**完全可靠**的逻辑信道。

为了实现这个目标，我们需要逐步解决一系列问题，这个解决过程也正好对应了可靠传输协议的演进。我们从最简单的协议开始。

#### **4.3.1 停止-等待协议 (Stop-and-Wait Protocol)**

这是最简单、最基础的可靠传输协议。它的核心思想是：**发送方每发送一个分组，就必须停下来，等待接收方的确认 (Acknowledgement, ACK)，收到确认后才能发送下一个分组。**

**1. 基本场景：无差错信道**

*   **流程**:
    1.  发送方发送分组0。
    2.  接收方收到分组0，向上层交付数据，然后回复一个ACK0。
    3.  发送方收到ACK0，知道分组0已成功送达，于是发送分组1。
    4.  ...如此循环。

**2. 引入差错：确认和超时重传**

*   **问题**: 如果分组在传输中**丢失**了，或者**损坏**了（接收方通过校验和发现并丢弃），发送方将永远等不到ACK，就会陷入**死锁**。
*   **解决方案**:
    1.  **确认 (ACK)**: 接收方收到正确的分组后，必须回复一个确认分组。
    2.  **超时重传 (Timeout Retransmission)**: 发送方在发送完一个分组后，会启动一个**定时器**。
        *   如果在定时器超时之前，收到了对应的ACK，就关闭定时器，发送下一个分组。
        *   如果在定时器超时之后，**仍然没有**收到ACK，发送方就**假定**之前发送的分组已经丢失，并**重新发送**同样的分组。

**3. 引入重复：分组编号**

*   **问题**: 超时重传又引入了新问题。
    *   **ACK丢失**: 如果分组成功到达，但接收方返回的ACK在路上丢失了。发送方定时器超时，会**重传**分组。接收方会收到一个**重复的分组**。
    *   **ACK迟到**: 如果ACK只是传输延迟，没有丢失。发送方超时重传了分组，然后又收到了那个迟到的ACK。
*   **解决方案**: **分组编号**。
    *   发送方为每个分组都赋予一个**唯一的序号 (Sequence Number)**。最简单的停止-等待协议只需要两个序号：0和1，交替使用。
    *   **发送方**: 维护一个发送序号，发送分组0，然后等待ACK0。收到ACK0后，下一个发送序号变为1。
    *   **接收方**: 维护一个期望接收的序号。
        *   如果收到的分组序号**等于**期望的序号，就接收它，向上层交付，然后将期望序号+1（或在0和1之间切换），并回复一个对应序号的ACK。
        *   如果收到的分组序号**不等于**期望的序号，说明这是一个**重复的分组**，就直接**丢弃**它，但依然要回复一个**上一个正确序号的ACK**（告诉发送方“我还在等那个旧的”）。

**停止-等待协议的总结**

*   **优点**: 简单易懂，是所有复杂可靠传输协议的基础。
*   **缺点**: **信道利用率极低**。在发送完一个分组后，整个信道在“等待ACK”的漫长时间里都是空闲的。这就像你寄一封信，必须等对方回信说收到了，你才能寄下一封，效率非常低下。

---

#### **4.3.2 连续ARQ协议 (Continuous ARQ Protocol)**

为了解决停止-等待协议的效率问题，**连续ARQ协议**应运而生。ARQ (Automatic Repeat reQuest) 即自动重传请求。

**核心思想**: 发送方可以**连续发送多个分组**，而无需每发送一个就停下来等待确认。这就像你可以一次性把一摞信都投进邮筒，而不用等第一封的回信。

为了实现这一点，连续ARQ协议引入了**滑动窗口 (Sliding Window)** 的概念。

**1. 滑动窗口**

*   **发送窗口**:
    *   在发送方，维护着一个允许它连续发送的分组序号范围，这个范围就是**发送窗口**。
    *   位于发送窗口内的分组，都可以被连续发送出去，而无需等待确认。
    *   发送窗口会随着收到接收方的确认而向前滑动。

*   **接收窗口**:
    *   在接收方，也维护着一个允许它接收的分组序号范围，这就是**接收窗口**。
    *   只有序号落在接收窗口内的分组才会被接收。

**2. 两种经典的连续ARQ协议**

连续ARQ协议主要有两种具体的实现方式，它们的区别在于如何处理出错/丢失的分组。

**A. 回退N帧协议 (Go-Back-N, GBN)**

*   **工作机制**:
    *   **发送窗口**: 大小可以 > 1。
    *   **接收窗口**: 大小**恒等于1**。
    *   **接收方**: 只接收**按序到达**的分组。如果收到了一个失序的分组（比如期望收到5号，却收到了7号），它会**直接丢弃**7号以及后续所有到达的分组，并反复发送对最后一个正确分组的确认（ACK4）。
    *   **发送方**:
        *   维护一个定时器，通常只为**最早发送但尚未被确认**的分组计时。
        *   如果定时器超时，发送方会**重新发送**那个超时的分组以及**它之后所有已发送过**的分组。这就是“回退N帧”这个名字的由来。
*   **优点**: 接收方逻辑简单，无需缓存失序的分组。
*   **缺点**: **效率较低**。即使后面只有一个分组出错，也要重传大量本已正确到达的分组，浪费了带宽。

**B. 选择重传协议 (Selective Repeat, SR)**

*   **工作机制**:
    *   **发送窗口**: 大小 > 1。
    *   **接收窗口**: 大小**也 > 1**。
    *   **接收方**:
        *   可以**缓存**那些失序到达、但序号落在接收窗口内的分组。
        *   对**每一个正确接收**的分组都**单独发送确认 (SACK - Selective ACK)**。
        *   当收到了一个期望的序号后（比如空缺的5号补上了），就可以将一段连续的分组向上层交付，并滑动接收窗口。
    *   **发送方**:
        *   为**每一个已发送但未确认**的分组都维护一个独立的定时器。
        *   如果哪个分组的定时器超时了，发送方**只重传那一个**分组。
*   **优点**: **效率极高**。实现了“哪里出错就补哪里”，最大限度地避免了不必要的重传。
*   **缺点**: 发送方和接收方的逻辑都**非常复杂**，需要维护更精细的状态和缓存。

**总结**
*   **TCP协议**的可靠传输机制，可以看作是**GBN和SR协议的混合体**。它在很多方面借鉴了这两种协议的思想，并进行了优化和改进，从而在复杂性和效率之间取得了很好的平衡。

---


### **4.4 传输控制协议 (TCP)**

#### **4.4.1 传输控制协议概述**

**TCP (Transmission Control Protocol)** 是TCP/IP协议栈中负责提供**可靠的、面向连接的**字节流服务的传输层协议。它是互联网上绝大多数应用（Web、Email、FTP等）的基石。

**TCP的核心特点回顾与深化**:

1.  **面向连接 (Connection-Oriented)**
    *   TCP通信的双方必须在传输数据之前，通过一个称为**“三次握手”**的过程来建立一个逻辑连接。
    *   这个连接为数据传输提供了一个可靠的通道。
    *   数据传输结束后，需要通过**“四次挥手”**来释放连接。

2.  **可靠传输 (Reliable Transport)**
    *   TCP利用我们在上一节学到的原理，并加以优化，来实现可靠性。它通过**序号、确认、超时重传、校验和**等机制，确保数据**不丢失、不重复、无差错、按顺序**地送达。

3.  **全双工通信 (Full-Duplex Communication)**
    *   在一个TCP连接上，通信双方的数据通路是双向的。两端可以**同时**进行数据的发送和接收。

4.  **面向字节流 (Byte-Stream-Oriented)**
    *   **这是TCP一个非常重要的概念**，与UDP的“面向报文”形成鲜明对比。
    *   **含义**: TCP不关心应用层传递下来的数据块的边界。在TCP看来，它要传输的数据，只是一个**无结构的、连续的字节序列**，就像一个流动的字节河。
    *   **行为**:
        *   TCP可能会将应用层发来的一个大数据库，**拆分**成多个小的TCP报文段来发送。
        *   也可能会将应用层连续发来的几个小数据块，**合并 (Nagle算法)** 成一个大的TCP报文段来发送，以提高网络效率。
    *   **对应用层的影响**: 接收方的应用程序从TCP接收数据时，也需要像从“河流”中读取数据一样，自己处理数据的边界问题。例如，发送方发送了两个HTTP请求，接收方可能一次性从TCP缓冲区里读出来一个半请求，需要应用层自己来解析和分割。

#### **4.4.2 TCP报文段格式**

TCP的数据单元称为**报文段 (Segment)**。它的首部（头部）比UDP复杂得多，包含了实现其可靠性、流量控制、拥塞控制等各种功能的字段。

TCP首部的**固定部分是20字节**，后面还可以跟最多40字节的选项字段。

```
  0      7 8     15 16    23 24    31
 +--------+--------+--------+--------+
 |     Source      |   Destination   |
 |      Port       |      Port       |
 +--------+--------+--------+--------+
 |                                   |
 |        Sequence Number (32)       |
 |                                   |
 +--------+--------+--------+--------+
 |                                   |
 |     Acknowledgement Number (32)   |
 |                                   |
 +--------+--------+--------+--------+
 | DO |  Reservd |   Flags (6)   |  Window Size (16)   |
 +--------+--------+--------+--------+
 |    Checksum (16)    | Urgent Pointer (16) |
 +--------+--------+--------+--------+
 |      Options (if any) ...       |
 +--------+--------+--------+--------+
 |                                   |
 |              Data ...             |
 |                                   |
 +-----------------------------------+

```

**TCP首部关键字段详解**:

*   **源端口 (Source Port, 16位)** 和 **目的端口 (Destination Port, 16位)**
    *   作用同UDP，用于标识发送和接收方的应用进程。

*   **序号 (Sequence Number, 32位)**
    *   **TCP最核心的字段之一**。
    *   由于TCP是面向字节流的，这个序号指的是本报文段所发送的**数据部分的第一个字节**在整个字节流中的**编号**。
    *   例如，如果一个报文段的序号是301，它携带了100字节的数据，那么这个报文段的数据就是字节流中的第301到400号字节。下一个报文段的序号就应该是401。
    *   **作用**: 实现数据的有序传输和确认机制。

*   **确认号 (Acknowledgement Number, 32位)**
    *   **TCP最核心的字段之二**。
    *   这个字段只有在 **ACK标志位** (见下) 为1时才有效。
    *   **含义**: 它告诉对方：“**我期望接收的下一个字节的序号是 `N`**”。这也就**隐含地确认**了序号在 `N-1` 之前的所有字节，我都已经**全部、正确地、按序地**收到了。这是一种**累计确认**机制。

*   **数据偏移 (Data Offset, 4位)**
    *   指的是TCP首部的长度，单位是 **4字节**。
    *   因为TCP首部有可选字段，所以长度是可变的。这个字段告诉接收方数据部分从哪里开始。
    *   4位能表示的最大值是15，所以TCP首部的最大长度是 `15 * 4 = 60` 字节。

*   **标志位 (Flags, 6位)**
    *   这是6个独立的比特位，每一位都有特殊的控制功能。
    *   **URG (Urgent)**: 紧急位。指示报文段中有紧急数据。
    *   **ACK (Acknowledgement)**: **确认位**。当ACK=1时，**确认号**字段才有效。
    *   **PSH (Push)**: 推送位。指示接收方应尽快将这个报文段的数据交付给应用层，而不要等待缓冲区填满。
    *   **RST (Reset)**: 复位位。用于异常地关闭一个连接。
    *   **SYN (Synchronization)**: **同步位**。在**连接建立**（三次握手）时使用，表示这是一个连接请求或连接接受报文。
    *   **FIN (Finish)**: **终止位**。在**连接释放**（四次挥手）时使用，表示发送方的数据已全部发送完毕。

*   **窗口大小 (Window Size, 16位)**
    *   用于**流量控制**。
    *   这个字段的值，是发送本报文段的一方（接收方）告诉对方（发送方）：“我现在的接收缓冲区还剩下 `N` 个字节的空间，你可以继续发送数据，但不要超过这个量。”
    *   它动态地向发送方宣告自己的接收能力。

*   **校验和 (Checksum, 16位)**
    *   用于检验首部和数据部分在传输过程中是否出错。计算方法与UDP类似，也包含一个IP伪首部。

*   **紧急指针 (Urgent Pointer, 16位)**
    *   只有当URG标志位为1时才有效，指出紧急数据在报文段中的结束位置。

*   **选项 (Options, 可变长)**
    *   用于携带一些额外的参数，如最大报文段长度 (MSS)、窗口扩大因子、选择性确认 (SACK) 信息等。

---
